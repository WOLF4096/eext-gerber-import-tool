<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerber 查看 / 导入PCB画布 / 生成PCB文件 / 导出PDF文件（预览版）</title>
    <!-- 浏览器环境 -->
    <script src="js/jszip.min.js"></script>
    <script src="js/jspdf.umd.min.js"></script>
    <!-- EDA环境 -->
    <script src="/iframe/js/jszip.min.js"></script>
    <script src="/iframe/js/jspdf.umd.min.js"></script>
    <!-- 单文件使用 -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> -->

    <style>

    /* --- 全局变量与基础重置 --- */
    :root { --bg-color: #1e1e1e; --panel-bg: #252526; --panel-header-bg: #333337; --text-color: #cccccc; --text-sub: #999999; --border-color: #3e3e42; --accent-color: #007acc; --accent-hover: #0062a3; --success-color: #2ea043; --hover-bg: #2a2d2e; --input-bg: #3c3c3c; --ruler-bg: #333333; --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; width: 100vw; height: 100vh; background-color: var(--bg-color); color: var(--text-color); font-family: var(--font-family); font-size: 13px; overflow: hidden; display: flex; }

    /* --- 画布区域 (Canvas) --- */
    #canvas-container { flex: 1; position: relative; background-color: #000; overflow: hidden; }
    canvas { display: block; }
    .ruler-h { position: absolute; top: 0; left: 0; height: 20px; width: 100%; background: var(--ruler-bg); z-index: 10; pointer-events: none; }
    .ruler-v { position: absolute; top: 0; left: 0; width: 20px; height: 100%; background: var(--ruler-bg); z-index: 10; pointer-events: none; }
    .unit-switch { position: absolute; top: 0; left: 0; width: 20px; height: 20px; background: #444; color: #fff; font-size: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 20; border-bottom: 1px solid #555; border-right: 1px solid #555; }
    .unit-switch:hover { background: var(--accent-color); }
    #loading-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; color: white; z-index: 100; }
    #global-drop-zone { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.85); z-index: 9999; display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: none; }
    #global-drop-zone.active { display: flex; pointer-events: auto; }
    .drop-text { font-size: 60px; color: var(--accent-color); }

    /* --- 侧边栏框架与 Tab 导航 --- */
    #sidebar { width: 320px; background-color: var(--panel-bg); border-left: 1px solid var(--border-color); display: flex; flex-direction: column; z-index: 30; }
    .sidebar-tabs { display: flex; background-color: #2d2d2d; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
    .tab-item { flex: 1; text-align: center; padding: 10px 0; font-size: 12px; font-weight: 600; cursor: pointer; color: var(--text-sub); border-bottom: 2px solid transparent; transition: all 0.2s; }
    .tab-item:hover { color: var(--text-color); background-color: var(--hover-bg); }
    .tab-item.active { color: #fff; border-bottom-color: var(--accent-color); background-color: var(--panel-bg); }
    .tab-content { flex: 1; display: none; flex-direction: column; overflow-y: auto; padding: 0; }
    .tab-content.active { display: flex; }

    /* --- 通用控件与排版 --- */
    .section-title { font-size: 12px; font-weight: bold; color: var(--text-sub); text-transform: uppercase; margin: 15px 15px 8px 15px; display: flex; align-items: center; justify-content: space-between; }
    .control-group { padding: 0 15px; margin-bottom: 15px; }
    .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: -6px; }
    .control-label { font-size: 12px; color: var(--text-color); }
    .sub-label { font-size: 11px; color: #888; margin-right: 8px; }

    /* --- 分段选择器 (Segmented Control) --- */
    .seg-control { display: flex; background: #111; border-radius: 4px; border: 1px solid var(--border-color); overflow: hidden; width: 100%; height: 26px; }
    .seg-btn { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 11px; color: #888; cursor: pointer; border-right: 1px solid #333; transition: background 0.2s; }
    .seg-btn:last-child { border-right: none; }
    .seg-btn:hover { background: #333; color: #ccc; }
    .seg-btn.active { background: var(--accent-color); color: white; font-weight: 600; }

    /* --- 步进器 (Stepper) --- */
    .stepper { display: flex; align-items: center; background: #111; border: 1px solid var(--border-color); border-radius: 4px; height: 24px; width: 80px; }
    .step-btn { width: 24px; height: 100%; display: flex; justify-content: center; align-items: center; cursor: pointer; color: #888; font-weight: bold; }
    .step-btn:hover { background-color: #333; color: #fff; }
    .step-val { flex: 1; text-align: center; font-family: 'Consolas', monospace; font-size: 12px; color: #fff; border-left: 1px solid #333; border-right: 1px solid #333; line-height: 22px; }

    /* --- 复选框行 --- */
    .checkbox-row { display: flex; align-items: center; padding: 8px 15px; background-color: var(--input-bg); margin: 0 15px 10px 15px; border-radius: 4px; cursor: pointer; }
    .checkbox-row:hover { background-color: #444; }
    .checkbox-row input { margin-right: 10px; }
    .checkbox-row span { font-size: 12px; }

    /* --- 按钮样式 --- */
    .btn-block { display: flex; align-items: center; justify-content: center; width: 100%; padding: 8px 0; margin-bottom: 10px; border: none; border-radius: 4px; font-size: 12px; font-weight: 600; cursor: pointer; color: white; transition: opacity 0.2s; }
    .btn-block:hover { opacity: 0.9; }
    .btn-primary { background-color: var(--accent-color); }
    .btn-success { background-color: var(--success-color); }
    .btn-secondary { background-color: #3e3e42; color: #ddd; }
    .btn-secondary:hover { background-color: #4e4e52; }
    .btn-group-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; padding: 0 15px; }
    .btn-small { background-color: #333; border: 1px solid var(--border-color); color: #ccc; padding: 8px 0; border-radius: 3px; font-size: 11px; cursor: pointer; text-align: center; }
    .btn-small:hover { border-color: var(--accent-color); color: white; background-color: #444; }

    /* --- DPI 选择器专用样式 --- */
    .dpi-combined-group { display: flex; background: #111; border-radius: 4px; border: 1px solid var(--border-color); overflow: hidden; height: 32px; margin-bottom: 12px; }
    .dpi-btn { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: #888; cursor: pointer; border-right: 1px solid #333; transition: all 0.2s; background: #181818; padding: 0 2px; white-space: nowrap; }
    .dpi-btn:hover { background: #333; color: #ccc; }
    .dpi-btn.active { background: var(--accent-color); color: white; }
    .dpi-input-wrapper { flex: 1.5; display: flex; align-items: center; background: var(--input-bg); padding: 0 6px 0 8px; border-left: 1px solid #333; }
    .dpi-custom-input-inline { flex: 1; width: 0; min-width: 30px; background: transparent; border: none; color: #fff; font-family: 'Consolas', monospace; font-size: 11px; text-align: right; outline: none; padding: 0; -moz-appearance: textfield; }
    .dpi-custom-input-inline::-webkit-outer-spin-button, .dpi-custom-input-inline::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .dpi-custom-input-inline:focus { color: var(--accent-color); }
    .dpi-unit-inline { font-size: 9px; color: #666; margin-left: 4px; font-weight: bold; white-space: nowrap; margin-top: 1px; }

    /* --- DEBUG区域 --- */
    #debug-panel { flex-direction: column; flex: 1; min-height: 200px; overflow: hidden; padding-bottom: 0; margin-bottom: 0; box-sizing: border-box; }
    #debug-source-area { width: 100%; flex: 1; height: auto !important; resize: none; box-sizing: border-box; display: block; margin-bottom: 0; border-bottom: none; border-radius: 0; }

    /* --- 图层列表与表格 --- */
    .layer-header { background-color: var(--panel-header-bg); padding: 6px 10px; font-weight: bold; border-bottom: 1px solid var(--border-color); border-top: 1px solid var(--border-color); display: flex; align-items: center; color: #eee; font-size: 11px; }
    .layer-table-head { display: flex; background: #222; padding: 5px; border-bottom: 1px solid #444; color: #aaa; font-size: 11px; font-weight: bold; }
    .layer-row { display: flex; align-items: center; padding: 4px 5px; border-bottom: 1px solid #2d2d30; }
    .layer-row:hover { background-color: var(--hover-bg); }
    .col-color { width: 30px; display: flex; justify-content: center; }
    .col-vis { width: 30px; display: flex; justify-content: center; }
    .col-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 5px; font-size: 12px; }
    .col-layer { width: 86px; }
    select.layer-select { width: 100%; background-color: var(--input-bg); color: #fff; border: 1px solid #555; padding: 2px; font-size: 11px; }
    input[type="color"] { -webkit-appearance: none; border: none; width: 14px; height: 14px; padding: 0; background: none; cursor: pointer; vertical-align: middle; }
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: 1px solid #666; border-radius: 2px; }

    /* --- 埋盲孔设置子行 --- */
    .layer-sub-row { display: flex; align-items: center; background-color: #222; padding: 5px 5px 5px 64px; border-bottom: 1px solid #2d2d30; font-size: 11px; color: #999; }
    .layer-sub-row select { background-color: #333; color: #eee; border: 1px solid #555; border-radius: 2px; padding: 1px 4px; margin: 0 8px 0 4px; font-size: 11px; width: 80px; }
    .arrow-icon { margin: 0 5px; color: #666; font-family: monospace; }

    /* --- 滚动条 --- */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-color); }
    ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }

    </style>
</head>
<body>
    <div id="global-drop-zone">
        <div class="drop-text">释放文件以加载 Gerber</div>
    </div>

    <div id="canvas-container">
        <div id="loading-overlay">正在解析 Gerber...</div>
        <div class="unit-switch" id="unit-btn" title="切换视图单位">mm</div>
        <canvas id="ruler-h" class="ruler-h" height="20"></canvas>
        <canvas id="ruler-v" class="ruler-v" width="20"></canvas>
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="sidebar">
        <div class="sidebar-tabs">
            <div class="tab-item active" onclick="switchTab('tab-config', this)">导入参数</div>
            <div class="tab-item" onclick="switchTab('tab-layers', this)">图层设置</div>
            <div class="tab-item" onclick="switchTab('tab-io', this)">导出选项</div>
        </div>
        <!-- 导入参数 -->
        <div id="tab-config" class="tab-content active">
            <div class="section-title" id="eda-export-title">获取当前板子</div>
            <div style="padding: 0 15px;" id="in-eda-gerber">
                <button class="btn-block btn-success" onclick="importCurrentGerber()">
                    导入当前板子 Gerber 图形
                </button>
            </div>

            <div class="section-title">选择文件 或 拖入文件至窗口</div>
            <div style="padding: 0 15px;">
                <button class="btn-block btn-primary" onclick="document.getElementById('file-input').click()">
                    导入 Gerber 压缩包 / 文件
                </button>
                <input type="file" id="file-input" multiple style="display:none" onchange="handleFileSelect(event)">
            </div>
            
            <div class="section-title">
                <span>图形坐标设置</span>
            </div>
            
            <div class="control-group">
                <div class="control-row" style="display: flex; justify-content: space-between; align-items: center;">
                    
                    <div class="seg-control" id="ui-units-group-graphic" style="width: 120px; margin-right: 10px;">
                        <div class="seg-btn active" onclick="setUnitUI('mm', 'graphic')" data-val="mm">毫米</div>
                        <div class="seg-btn" onclick="setUnitUI('in', 'graphic')" data-val="in">英寸</div>
                        <div class="seg-btn" onclick="setUnitUI('auto', 'graphic')" data-val="auto" style="display:none">自动</div>
                    </div>

                    <div style="display: flex; align-items: center;">
                        <span class="sub-label" style="margin-right: 6px; color: #999;">小数位</span>
                        <div class="stepper" style="width: 70px;">
                            <div class="step-btn" onclick="stepVal('cfg-dec', -1)">-</div>
                            <div class="step-val" id="ui-val-dec">5</div>
                            <div class="step-btn" onclick="stepVal('cfg-dec', 1)">+</div>
                        </div>
                    </div>

                </div>
            </div>

            <div class="section-title">
                <span>钻孔坐标设置</span>
            </div>

            <div class="control-group">
                <div class="control-row" style="display: flex; justify-content: space-between; align-items: center;">
                    
                    <div class="seg-control" id="ui-units-group-drill" style="width: 120px; margin-right: 10px;">
                        <div class="seg-btn active" onclick="setUnitUI('mm', 'drill')" data-val="mm">毫米</div>
                        <div class="seg-btn" onclick="setUnitUI('in', 'drill')" data-val="in">英寸</div>
                        <div class="seg-btn" onclick="setUnitUI('auto', 'drill')" data-val="auto" style="display:none">自动</div>
                    </div>

                    <div style="display: flex; align-items: center;">
                        <span class="sub-label" style="margin-right: 6px; color: #999;">小数位</span>
                        <div class="stepper" style="width: 70px;">
                            <div class="step-btn" onclick="stepVal('cfg-d-dec', -1)">-</div>
                            <div class="step-val" id="ui-val-d-dec">4</div>
                            <div class="step-btn" onclick="stepVal('cfg-d-dec', 1)">+</div>
                        </div>
                    </div>

                </div>
            </div>
            
            <div style="padding: 15px;">
                <button class="btn-block btn-primary" onclick="reparseFiles()">应用参数并重载</button>
                <button class="btn-block btn-secondary" onclick="resetConfig()">恢复默认设置</button>
            </div>

            <div class="section-title">板子属性</div>
            <div class="control-group" style="padding: 5px 15px; border-radius: 4px;">
                <div class="control-row">
                    <span class="control-label" style="color:#999;">尺寸</span>
                    <span id="prop-dim" style="font-family:'Consolas',monospace; color:#fff;">-</span>
                </div>
                <div class="control-row" style="margin-top:8px;">
                    <span class="control-label" style="color:#999;">层数</span>
                    <span id="prop-layers" style="font-family:'Consolas',monospace; color:#fff;">-</span>
                </div>
                <div class="control-row" style="margin-top:8px;">
                    <span class="control-label" style="color:#999;">通孔</span>
                    <span id="prop-th" style="font-family:'Consolas',monospace; color:#fff;">0</span>
                </div>
                <div class="control-row" id="row-prop-bb" style="margin-top:8px; display:none;">
                    <span class="control-label" style="color:#999;">埋盲孔</span>
                    <span id="prop-bb" style="font-family:'Consolas',monospace; color:#fff;">0</span>
                </div>
            </div>


            <input type="hidden" id="cfg-units" value="mm">
            <input type="hidden" id="cfg-d-units" value="mm"> 
            <input type="number" id="cfg-dec" value="5" min="1" max="8" style="display:none">
            <input type="hidden" id="cfg-g-int" value="2">
            <input type="hidden" id="cfg-d-int" value="2">
            <input type="hidden" id="cfg-d-dec" value="4">
        </div>
        <!-- 图层设置 -->
        <div id="tab-layers" class="tab-content">
            <div style="padding: 10px 15px; border-bottom: 1px solid #3e3e42; display: flex; align-items: center; justify-content: flex-start; gap: 20px; margin-top: 13px;">
                <div style="display: flex; align-items: center;">
                    <span class="control-label" style="margin-right: 8px; white-space: nowrap;">铜层数</span>
                    <select id="cfg-copper-layers" class="layer-select" 
                        style="width: 80px; height: 26px; border-radius: 4px; cursor: pointer; padding-left: 6px;"
                        onchange="handleLayerCountChange(this.value)">
                        </select>
                </div>
                
                <div style="display: flex; align-items: center;">
                    <span class="control-label" style="margin-right: 8px; white-space: nowrap;">类型</span>
                    <div class="seg-control" id="ui-board-type" style="width: 100px;">
                        <div class="seg-btn active" onclick="setBoardType('PCB')" data-val="PCB">PCB</div>
                        <div class="seg-btn" onclick="setBoardType('FPC')" data-val="FPC">FPC</div>
                        <!-- 当前版本工具暂不支持FPC，待后续更新 -->
                    </div>
                </div>
                
                <input type="hidden" id="cfg-board-type" value="PCB">

            </div>
            <div class="section-title">注意：选错图层类型可能会导入失败 ！！！</div>
            <div id="layer-list-content">
                <div class="layer-table-head">
                    <div class="col-color">颜色</div>
                    <div class="col-vis">启用</div>
                    <div class="col-name">文件名</div>
                    <div class="col-layer">图层类型</div>
                </div>
                <div style="padding: 20px; text-align: center; color: #666;">
                    请先导入文件
                </div>
            </div>
        </div>
        <!-- 导出选项 -->
        <div id="tab-io" class="tab-content">

            <div style="padding: 10px 15px; font-size: 12px; line-height: 1.5; color: #999; border-bottom: 1px solid #333;">
                <div style="color: #ff9800; font-weight: bold; margin-bottom: 4px;">⚠️ 当前为预览版本，非最终版本</div>
                <ul style="margin: 0; padding-left: 16px; color: #ccc;">
                    <li>当前仅支持 <strong>嘉立创EDA专业版 V2.2+</strong> Gerber 文件</li>
                    <li>渲染画面仅供参考，请以实际导入为准</li>
                    <li>如果一直导入失败可 <strong>重启EDA软件</strong> 重试</li>
                    <li>文件 >2MB 时，建议 <strong>导出文件</strong> 后手动导入</li>
                </ul>
            </div>

            <div class="section-title" id="ui-export-canvas-title">导出至当前 PCB 画布</div>
            
            <div class="control-group">
                <div class="control-row" style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center;">
                        <span style="font-size: 12px; margin-right: 8px; white-space: nowrap;">处理模式:</span>
                        <select id="cfg-source-type" class="layer-select" style="width: 232px; height: 26px; border-radius: 3px; cursor: pointer; padding-left: 4px;">
                            <option value="easyedapro" selected>嘉立创EDA专业版 V2.2 / V3 专用</option>
                            <option value="compatible">兼容模式 (开发中)</option>
                            <option value="other">保底模式 (开发中)</option>
                        </select>
                    </div>

                    <label id="generatenet" style="display: flex; align-items: center; justify-content: flex-start; cursor: pointer; height: 26px; width: 110px; background-color: #3c3c3c; border: 1px solid #555; border-radius: 3px; user-select: none; padding-left: 8px; box-sizing: border-box;">
                        <input type="checkbox" id="cfg-netlist" style="margin: 0 6px 0 0; cursor: pointer;" checked>
                        <span style="font-size: 12px; color: #ccc; white-space: nowrap;">尝试生成网络</span>
                    </label>
                </div>
            </div>

            <div style="padding: 0 15px;" id="ui-export-canvas-btn-wrapper">
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <button class="btn-block btn-success" onclick="handleExportToCanvas('source')" style="flex: 1;">
                        通过源码导入
                    </button>
                    <button class="btn-block btn-primary" onclick="handleExportToCanvas('api')" style="flex: 1; background-color: #007acc;">
                        通过图元导入
                    </button>
                </div>
            </div>
            
            <div class="section-title">导出嘉立创 EDA</div>
            <div class="btn-group-grid">
                <div class="btn-small" onclick="handleExportStandard()">标准版</div>
                <div class="btn-small" onclick="handleExportProV2()">专业版 V2</div>
                <div class="btn-small" onclick="handleExportProV3()">专业版 V3</div>
            </div>

            <div class="section-title" style="margin-top: 20px;">导出位图 PDF</div>
            <div style="padding: 0 15px;">
                
                <div class="dpi-combined-group" id="ui-dpi-group">
                    <div class="dpi-input-wrapper" title="点击输入自定义值">
                        <input type="number" id="ui-dpi-input" class="dpi-custom-input-inline" 
                            value="600" min="1" max="4800" step="100"
                            oninput="handleCustomDpiInput(this.value)"
                            onfocus="this.select()">
                        <span class="dpi-unit-inline">DPI</span>
                    </div>
                    
                    <div class="dpi-btn" onclick="updateDpiUI(300)" data-val="300">300</div>
                    <div class="dpi-btn active" onclick="updateDpiUI(600)" data-val="600">600</div>
                    <div class="dpi-btn" onclick="updateDpiUI(900)" data-val="900">900</div>
                    <div class="dpi-btn" onclick="updateDpiUI(1200)" data-val="1200">1200</div>
                    
                </div>

                <input type="hidden" id="cfg-dpi" value="600">
            </div>

            <div class="btn-group-grid">
                <div class="btn-small" onclick="exportPDF('single')" title="仅导出当前可视画面">当前内容</div>
                <div class="btn-small" onclick="exportPDF('multi')" title="仅导出已勾选的图层">启用图层</div>
                <div class="btn-small" onclick="exportPDF('all')" title="导出所有图层，每层一页">全部图层</div>
            </div>

            <div id="debug-panel" style="display:none; padding-top: 10px;">
                <div class="section-title" style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="debug-panel-title">图形源码 (DEBUG)</span>
                    <div style="display: flex; gap: 8px;">
                        <button id="btn-debug-gen" class="btn-small" onclick="generateDebugSource()" style="width: 60px; padding: 2px 0;">生成</button>
                        <button id="btn-debug-copy" class="btn-small" onclick="copyDebugSource()" style="width: 60px; padding: 2px 0;">复制</button>
                    </div>
                </div>
                <textarea id="debug-source-area" readonly spellcheck="false" style="width: 100%; background-color: #111; color: #cccccc; border: 1px solid #444; font-family: 'Consolas', monospace; font-size: 11px; padding: 5px; white-space: pre; overflow: auto;"></textarea>
            </div>
        </div>
    </div>
<script>

// ====================================================================================
// 1. 全局常量与配置
// ====================================================================================

    // --- 调试开关 ---
    // let DEBUG = true;  // 开启调试模式
    let DEBUG = false; // 关闭调试模式

    // --- 全局变量 ---
    let currentZipName = null; // 用于存储当前导入的压缩包名
    let flyingProbeData = null; //用于存储飞针测试数据

    // 标准版头文件
    const LCEDA_STD_Head_Source = ``; 

    // 专业版 V2 头文件
    const LCEDA_V2_Head_Source = `["DOCTYPE","PCB","1.8"]
["HEAD",{"editorVersion":"2.2.45.5","importFlag":0}]
["CANVAS",0,0,"mil",5,5,1,1,10,10,0,0,5]
["LAYER",1,"TOP","Top Layer",3,"#cc6633",1,"#7f0000",1]
["LAYER",2,"BOTTOM","Bottom Layer",3,"#6699ff",1,"#00007f",1]
["LAYER",3,"TOP_SILK","Top Silkscreen Layer",3,"#ffcc00",0.9,"#7f6600",1]
["LAYER",4,"BOT_SILK","Bottom Silkscreen Layer",3,"#66cc33",0.9,"#336619",1]
["LAYER",5,"TOP_SOLDER_MASK","Top Solder Mask Layer",3,"#800080",0.7,"#400040",1]
["LAYER",6,"BOT_SOLDER_MASK","Bottom Solder Mask Layer",3,"#aa00ff",0.7,"#55007f",1]
["LAYER",7,"TOP_PASTE_MASK","Top Paste Mask Layer",3,"#808080",1,"#404040",1]
["LAYER",8,"BOT_PASTE_MASK","Bottom Paste Mask Layer",3,"#800000",1,"#400000",1]
["LAYER",9,"TOP_ASSEMBLY","Top Assembly Layer",3,"#33cc99",1,"#19664c",1]
["LAYER",10,"BOT_ASSEMBLY","Bottom Assembly Layer",3,"#5555ff",1,"#2a2a7f",1]
["LAYER",11,"OUTLINE","Board Outline Layer",3,"#ff00ff",1,"#7f007f",1]
["LAYER",12,"MULTI","Multi-Layer",3,"#c0c0c0",0.5,"#606060",1]
["LAYER",13,"DOCUMENT","Document Layer",3,"#ffffff",1,"#7f7f7f",1]
["LAYER",14,"MECHANICAL","Mechanical Layer",3,"#f022f0",1,"#781178",1]
["LAYER",15,"SIGNAL","Inner1",3,"#999966",1,"#4c4c33",1]
["LAYER",16,"SIGNAL","Inner2",3,"#0099cc",1,"#004000",1]
["LAYER",17,"SIGNAL","Inner3",3,"#339999",1,"#007f00",1]
["LAYER",18,"SIGNAL","Inner4",3,"#bc8e00",1,"#5e4700",1]
["LAYER",19,"SIGNAL","Inner5",0,"#70dbfa",1,"#39503f",1]
["LAYER",20,"SIGNAL","Inner6",0,"#00cc66",1,"#006633",1]
["LAYER",21,"SIGNAL","Inner7",0,"#9966ff",1,"#4c337f",1]
["LAYER",22,"SIGNAL","Inner8",0,"#800080",1,"#400040",1]
["LAYER",23,"SIGNAL","Inner9",0,"#008080",1,"#004040",1]
["LAYER",24,"SIGNAL","Inner10",0,"#15935f",1,"#0a492f",1]
["LAYER",25,"SIGNAL","Inner11",0,"#000080",1,"#000040",1]
["LAYER",26,"SIGNAL","Inner12",0,"#00b400",1,"#005a00",1]
["LAYER",27,"SIGNAL","Inner13",0,"#2e4756",1,"#17232b",1]
["LAYER",28,"SIGNAL","Inner14",0,"#99842f",1,"#4c4217",1]
["LAYER",29,"SIGNAL","Inner15",0,"#ffffaa",1,"#7f7f55",1]
["LAYER",30,"SIGNAL","Inner16",0,"#99842f",1,"#4c4217",1]
["LAYER",31,"SIGNAL","Inner17",0,"#2e4756",1,"#17232b",1]
["LAYER",32,"SIGNAL","Inner18",0,"#3535ff",1,"#1a1a7f",1]
["LAYER",33,"SIGNAL","Inner19",0,"#8000bc",1,"#40005e",1]
["LAYER",34,"SIGNAL","Inner20",0,"#43ae5f",1,"#21572f",1]
["LAYER",35,"SIGNAL","Inner21",0,"#c3ecce",1,"#617667",1]
["LAYER",36,"SIGNAL","Inner22",0,"#728978",1,"#39443c",1]
["LAYER",37,"SIGNAL","Inner23",0,"#39503f",1,"#1c281f",1]
["LAYER",38,"SIGNAL","Inner24",0,"#0c715d",1,"#06382e",1]
["LAYER",39,"SIGNAL","Inner25",0,"#5a8a80",1,"#2d4540",1]
["LAYER",40,"SIGNAL","Inner26",0,"#2b937e",1,"#15493f",1]
["LAYER",41,"SIGNAL","Inner27",0,"#23999d",1,"#114c4e",1]
["LAYER",42,"SIGNAL","Inner28",0,"#45b4e3",1,"#225a71",1]
["LAYER",43,"SIGNAL","Inner29",0,"#215da1",1,"#102e50",1]
["LAYER",44,"SIGNAL","Inner30",0,"#4564d7",1,"#22326b",1]
["LAYER",45,"SIGNAL","Inner31",0,"#6969e9",1,"#343474",1]
["LAYER",46,"SIGNAL","Inner32",0,"#9069e9",1,"#483474",1]
["LAYER",47,"HOLE","Hole Layer",3,"#222222",0.5,"#111111",1]
["LAYER",48,"COMPONENT_SHAPE","Component Shape Layer",3,"#00cccc",1,"#006666",1]
["LAYER",49,"COMPONENT_MARKING","Component Marking Layer",3,"#66ffcc",1,"#337f66",1]
["LAYER",50,"PIN_SOLDERING","Pin Soldering Layer",3,"#cc9999",1,"#664c4c",1]
["LAYER",51,"PIN_FLOATING","Pin Floating Layer",3,"#ff99ff",1,"#7f4c7f",1]
["LAYER",52,"COMPONENT_MODEL","Component Model Layer",0,"#ffffff",1,"#7f7f7f",1]
["LAYER",53,"3D_SHELL_OUTLINE","3D Shell Outline Layer",3,"#66ff99",1,"#337f4c",1]
["LAYER",54,"3D_SHELL_TOP","3D Shell Top Layer",3,"#ffccff",1,"#7f667f",1]
["LAYER",55,"3D_SHELL_BOTTOM","3D Shell Bottom Layer",3,"#0066cc",1,"#003366",1]
["LAYER",56,"DRILL_DRAWING","Drill Drawing Layer",3,"#008080",1,"#004040",1]
["LAYER",57,"OTHER","Ratline Layer",7,"#6464ff",1,"#32327f",1]
["LAYER",58,"TOP_STIFFENER","Top Stiffener Layer",0,"#eee666",1,"#777333",1]
["LAYER",59,"BOTTOM_STIFFENER","Bottom Stiffener Layer",0,"#ccff00",1,"#667f00",1]
["LAYER",71,"CUSTOM","Custom1",0,"#9069e9",1,"#483474",1]
["LAYER",72,"CUSTOM","Custom2",0,"#6969e9",1,"#343474",1]
["LAYER",73,"CUSTOM","Custom3",0,"#4564d7",1,"#22326b",1]
["LAYER",74,"CUSTOM","Custom4",0,"#215da1",1,"#102e50",1]
["LAYER",75,"CUSTOM","Custom5",0,"#45b4e3",1,"#225a71",1]
["LAYER",76,"CUSTOM","Custom6",0,"#23999d",1,"#114c4e",1]
["LAYER",77,"CUSTOM","Custom7",0,"#2b937e",1,"#15493f",1]
["LAYER",78,"CUSTOM","Custom8",0,"#5a8a80",1,"#2d4540",1]
["LAYER",79,"CUSTOM","Custom9",0,"#0c715d",1,"#06382e",1]
["LAYER",80,"CUSTOM","Custom10",0,"#39503f",1,"#1c281f",1]
["LAYER",81,"CUSTOM","Custom11",0,"#728978",1,"#39443c",1]
["LAYER",82,"CUSTOM","Custom12",0,"#c3ecce",1,"#617667",1]
["LAYER",83,"CUSTOM","Custom13",0,"#43ae5f",1,"#21572f",1]
["LAYER",84,"CUSTOM","Custom14",0,"#8000bc",1,"#40005e",1]
["LAYER",85,"CUSTOM","Custom15",0,"#3535ff",1,"#1a1a7f",1]
["LAYER",86,"CUSTOM","Custom16",0,"#2e4756",1,"#17232b",1]
["LAYER",87,"CUSTOM","Custom17",0,"#99842f",1,"#4c4217",1]
["LAYER",88,"CUSTOM","Custom18",0,"#ffffaa",1,"#7f7f55",1]
["LAYER",89,"CUSTOM","Custom19",0,"#99842f",1,"#4c4217",1]
["LAYER",90,"CUSTOM","Custom20",0,"#2e4756",1,"#17232b",1]
["LAYER",91,"CUSTOM","Custom21",0,"#00b400",1,"#005a00",1]
["LAYER",92,"CUSTOM","Custom22",0,"#000080",1,"#000040",1]
["LAYER",93,"CUSTOM","Custom23",0,"#15935f",1,"#0a492f",1]
["LAYER",94,"CUSTOM","Custom24",0,"#008080",1,"#004040",1]
["LAYER",95,"CUSTOM","Custom25",0,"#800080",1,"#400040",1]
["LAYER",96,"CUSTOM","Custom26",0,"#9966ff",1,"#4c337f",1]
["LAYER",97,"CUSTOM","Custom27",0,"#00cc66",1,"#006633",1]
["LAYER",98,"CUSTOM","Custom28",0,"#70dbfa",1,"#39503f",1]
["LAYER",99,"CUSTOM","Custom29",0,"#bc8e00",1,"#5e4700",1]
["LAYER",100,"CUSTOM","Custom30",0,"#00ff00",1,"#007f00",1]
["LAYER",361,"SUBSTRATE","Dielectric1",0,"#000000",0,"#000000",1]
["LAYER",362,"SUBSTRATE","Dielectric2",0,"#000000",0,"#000000",1]
["LAYER",363,"SUBSTRATE","Dielectric3",0,"#000000",0,"#000000",1]
["LAYER",364,"SUBSTRATE","Dielectric4",0,"#000000",0,"#000000",1]
["LAYER",365,"SUBSTRATE","Dielectric5",0,"#000000",0,"#000000",1]
["LAYER",366,"SUBSTRATE","Dielectric6",0,"#000000",0,"#000000",1]
["LAYER",367,"SUBSTRATE","Dielectric7",0,"#000000",0,"#000000",1]
["LAYER",368,"SUBSTRATE","Dielectric8",0,"#000000",0,"#000000",1]
["LAYER",369,"SUBSTRATE","Dielectric9",0,"#000000",0,"#000000",1]
["ACTIVE_LAYER",1]
["RULE_TEMPLATE","自定义配置"]
["RULE","1","copperThickness1oz",1,["mil",[[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]]]
["RULE","1","copperThickness2oz",0,["mil",[[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]]]
["RULE","1","copperThicknessInner0.5oz",0,["mil",[[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]]]
["RULE","2","otherClearance",1,["mil",0,0,0]]
["RULE","3","copperThickness1oz",1,["mil",1,10,100]]
["RULE","3","copperThickness2oz",0,["mil",1,10,100]]
["RULE","3","copperThickness0.5oz",0,["mil",1,10,100]]
["RULE","11","netLength",1,["mil",0,0]]
["RULE","10","differentialPair",1,["mil",5,10,100,5.9843,5.9843,0,10]]
["RULE","4","blindVia",1,[]]
["RULE","5","viaSize",1,["mil",0.5,12.0079,196.8504,0.5,6.0039,124.0158]]
["RULE","6","innerPlane",1,["mil",10,10,0,10,10,90,"0",10,10,90]]
["RULE","7","copperRegion",1,["mil",10,10,1,10,10,90,"0",1,10,10,90]]
["RULE","8","pasteMaskExpansion",1,["mil",0,0,-1000,-1000]]
["RULE","9","solderMaskExpansion",1,["mil",2.0079,2.0079,-1000,-1000,2.0079,2.0079]]
["RULE","12","Common",1,[0,1,0,1,0,[1,2,12],[]]]
["PRIMITIVE","ALL",1,0]
["PRIMITIVE","COMPONENT",1,1]
["PRIMITIVE","PROPERTY",1,1]
["PRIMITIVE","COMPONENTSILK",1,1]
["PRIMITIVE","TRACK",1,1]
["PRIMITIVE","VIA",1,1]
["PRIMITIVE","TESTPOINT",1,1]
["PRIMITIVE","PAD",1,1]
["PRIMITIVE","PADSPAIR",1,0]
["PRIMITIVE","NETWORK",1,0]
["PRIMITIVE","SUTUREHOLE",1,1]
["PRIMITIVE","TEARDROP",1,1]
["PRIMITIVE","RATLINE",0,0]
["PRIMITIVE","GROUP",1,0]
["PRIMITIVE","TEXT",1,1]
["PRIMITIVE","IMAGE",1,1]
["PRIMITIVE","PICTURE",1,1]
["PRIMITIVE","DIMENSION",1,1]
["PRIMITIVE","BOARDOUTLINE",1,1]
["PRIMITIVE","SLOTREGION",1,1]
["PRIMITIVE","FILLREGIEN",1,1]
["PRIMITIVE","COPPEROUTLINE",1,1]
["PRIMITIVE","COPPERFILLED",1,1]
["PRIMITIVE","PROHIBITEDREGION",1,1]
["PRIMITIVE","CONSTRAINT",1,1]
["PRIMITIVE","PARTITION",0,0]
["PRIMITIVE","LINE",1,1]
["PRIMITIVE","LOCKED",1,1]
["PRIMITIVE","UNLOCKED",1,1]
["PRIMITIVE","SHELL",1,1]
["PRIMITIVE","BOSS",1,1]
["PRIMITIVE","CREASE",1,1]
["PRIMITIVE","TOPSHELLCUT",1,1]
["PRIMITIVE","SIDESHELLCUT",1,1]
["PRIMITIVE","TOPBOTTOMENTITY",1,1]
["PRIMITIVE","SIDEENTITY",1,1]
["PRIMITIVE","FPC_STIFFENER",1,1]
["SILK_OPTS",3,"#000000","#FFFFFF"]
["SILK_OPTS",4,"#000000","#FFFFFF"]
["PREFERENCE",1,10,1,20,50,1,0,"L45",0,0,1,1,"JLC06161H-3313",0,3,"OPTIMIZA_OPEN",0,"OPTIMIZA_NONE",true,true]
["PANELIZE",0,1,1,0,0,1]
["PANELIZE_STAMP",1,0,1,21.6535,8,33.4646]
["PANELIZE_SIDE",1,1,236.2205,78.7402,39.3701,19.685]
["PANELIZE_STAMP",0,0,1,21.6535,8,33.4646]
["PANELIZE_SIDE",0,0,236.2205,78.7402,39.3701,19.685]`.trim();

    // 专业版 V3 头文件
    const LCEDA_V3_Head_Source = `{"type":"DOCHEAD"}||{"docType":"PCB","client":"6af495b598287a2d","uuid":"2ffffa5e735e7565","updateTime":1770062807370,"version":"1770062807370"}|
{"type":"CANVAS","ticket":1,"id":"CANVAS"}||{"originX":0,"originY":0,"unit":"mil","gridXSize":5,"gridYSize":5,"snapXSize":5,"snapYSize":5,"altSnapXSize":10,"altSnapYSize":10,"gridType":"NONE","multiGridType":"NONE","multiGridRatio":5,"highlightValue":0.5}|
{"type":"LAYER","ticket":2,"id":"[\\"LAYER\\",1]"}||{"layerId":1,"layerType":"TOP","layerName":"Top Layer","use":true,"show":true,"locked":false,"activeColor":"#cc6633","activateTransparency":1,"inactiveColor":"#7f0000","inactiveTransparency":1}|
{"type":"LAYER","ticket":3,"id":"[\\"LAYER\\",2]"}||{"layerId":2,"layerType":"BOTTOM","layerName":"Bottom Layer","use":true,"show":true,"locked":false,"activeColor":"#6699ff","activateTransparency":1,"inactiveColor":"#00007f","inactiveTransparency":1}|
{"type":"LAYER","ticket":4,"id":"[\\"LAYER\\",3]"}||{"layerId":3,"layerType":"TOP_SILK","layerName":"Top Silkscreen Layer","use":true,"show":true,"locked":false,"activeColor":"#ffcc00","activateTransparency":0.9,"inactiveColor":"#7f6600","inactiveTransparency":1}|
{"type":"LAYER","ticket":5,"id":"[\\"LAYER\\",4]"}||{"layerId":4,"layerType":"BOT_SILK","layerName":"Bottom Silkscreen Layer","use":true,"show":true,"locked":false,"activeColor":"#66cc33","activateTransparency":0.9,"inactiveColor":"#336619","inactiveTransparency":1}|
{"type":"LAYER","ticket":6,"id":"[\\"LAYER\\",5]"}||{"layerId":5,"layerType":"TOP_SOLDER_MASK","layerName":"Top Solder Mask Layer","use":true,"show":true,"locked":false,"activeColor":"#800080","activateTransparency":0.7,"inactiveColor":"#400040","inactiveTransparency":1}|
{"type":"LAYER","ticket":7,"id":"[\\"LAYER\\",6]"}||{"layerId":6,"layerType":"BOT_SOLDER_MASK","layerName":"Bottom Solder Mask Layer","use":true,"show":true,"locked":false,"activeColor":"#aa00ff","activateTransparency":0.7,"inactiveColor":"#55007f","inactiveTransparency":1}|
{"type":"LAYER","ticket":8,"id":"[\\"LAYER\\",7]"}||{"layerId":7,"layerType":"TOP_PASTE_MASK","layerName":"Top Paste Mask Layer","use":true,"show":true,"locked":false,"activeColor":"#808080","activateTransparency":1,"inactiveColor":"#404040","inactiveTransparency":1}|
{"type":"LAYER","ticket":9,"id":"[\\"LAYER\\",8]"}||{"layerId":8,"layerType":"BOT_PASTE_MASK","layerName":"Bottom Paste Mask Layer","use":true,"show":true,"locked":false,"activeColor":"#800000","activateTransparency":1,"inactiveColor":"#400000","inactiveTransparency":1}|
{"type":"LAYER","ticket":10,"id":"[\\"LAYER\\",9]"}||{"layerId":9,"layerType":"TOP_ASSEMBLY","layerName":"Top Assembly Layer","use":true,"show":true,"locked":false,"activeColor":"#33cc99","activateTransparency":1,"inactiveColor":"#19664c","inactiveTransparency":1}|
{"type":"LAYER","ticket":11,"id":"[\\"LAYER\\",10]"}||{"layerId":10,"layerType":"BOT_ASSEMBLY","layerName":"Bottom Assembly Layer","use":true,"show":true,"locked":false,"activeColor":"#5555ff","activateTransparency":1,"inactiveColor":"#2a2a7f","inactiveTransparency":1}|
{"type":"LAYER","ticket":12,"id":"[\\"LAYER\\",11]"}||{"layerId":11,"layerType":"OUTLINE","layerName":"Board Outline Layer","use":true,"show":true,"locked":false,"activeColor":"#ff00ff","activateTransparency":1,"inactiveColor":"#7f007f","inactiveTransparency":1}|
{"type":"LAYER","ticket":13,"id":"[\\"LAYER\\",12]"}||{"layerId":12,"layerType":"MULTI","layerName":"Multi-Layer","use":true,"show":true,"locked":false,"activeColor":"#c0c0c0","activateTransparency":0.5,"inactiveColor":"#606060","inactiveTransparency":1}|
{"type":"LAYER","ticket":14,"id":"[\\"LAYER\\",13]"}||{"layerId":13,"layerType":"DOCUMENT","layerName":"Document Layer","use":true,"show":true,"locked":false,"activeColor":"#ffffff","activateTransparency":1,"inactiveColor":"#7f7f7f","inactiveTransparency":1}|
{"type":"LAYER","ticket":15,"id":"[\\"LAYER\\",14]"}||{"layerId":14,"layerType":"MECHANICAL","layerName":"Mechanical Layer","use":true,"show":true,"locked":false,"activeColor":"#f022f0","activateTransparency":1,"inactiveColor":"#781178","inactiveTransparency":1}|
{"type":"LAYER","ticket":16,"id":"[\\"LAYER\\",15]"}||{"layerId":15,"layerType":"SIGNAL","layerName":"Inner1","use":true,"show":true,"locked":false,"activeColor":"#999966","activateTransparency":1,"inactiveColor":"#4c4c33","inactiveTransparency":1}|
{"type":"LAYER","ticket":17,"id":"[\\"LAYER\\",16]"}||{"layerId":16,"layerType":"SIGNAL","layerName":"Inner2","use":true,"show":true,"locked":false,"activeColor":"#0099cc","activateTransparency":1,"inactiveColor":"#004000","inactiveTransparency":1}|
{"type":"LAYER","ticket":18,"id":"[\\"LAYER\\",17]"}||{"layerId":17,"layerType":"SIGNAL","layerName":"Inner3","use":true,"show":true,"locked":false,"activeColor":"#339999","activateTransparency":1,"inactiveColor":"#007f00","inactiveTransparency":1}|
{"type":"LAYER","ticket":19,"id":"[\\"LAYER\\",18]"}||{"layerId":18,"layerType":"SIGNAL","layerName":"Inner4","use":true,"show":true,"locked":false,"activeColor":"#bc8e00","activateTransparency":1,"inactiveColor":"#5e4700","inactiveTransparency":1}|
{"type":"LAYER","ticket":20,"id":"[\\"LAYER\\",19]"}||{"layerId":19,"layerType":"SIGNAL","layerName":"Inner5","use":false,"show":false,"locked":false,"activeColor":"#70dbfa","activateTransparency":1,"inactiveColor":"#39503f","inactiveTransparency":1}|
{"type":"LAYER","ticket":21,"id":"[\\"LAYER\\",20]"}||{"layerId":20,"layerType":"SIGNAL","layerName":"Inner6","use":false,"show":false,"locked":false,"activeColor":"#00cc66","activateTransparency":1,"inactiveColor":"#006633","inactiveTransparency":1}|
{"type":"LAYER","ticket":22,"id":"[\\"LAYER\\",21]"}||{"layerId":21,"layerType":"SIGNAL","layerName":"Inner7","use":false,"show":false,"locked":false,"activeColor":"#9966ff","activateTransparency":1,"inactiveColor":"#4c337f","inactiveTransparency":1}|
{"type":"LAYER","ticket":23,"id":"[\\"LAYER\\",22]"}||{"layerId":22,"layerType":"SIGNAL","layerName":"Inner8","use":false,"show":false,"locked":false,"activeColor":"#800080","activateTransparency":1,"inactiveColor":"#400040","inactiveTransparency":1}|
{"type":"LAYER","ticket":24,"id":"[\\"LAYER\\",23]"}||{"layerId":23,"layerType":"SIGNAL","layerName":"Inner9","use":false,"show":false,"locked":false,"activeColor":"#008080","activateTransparency":1,"inactiveColor":"#004040","inactiveTransparency":1}|
{"type":"LAYER","ticket":25,"id":"[\\"LAYER\\",24]"}||{"layerId":24,"layerType":"SIGNAL","layerName":"Inner10","use":false,"show":false,"locked":false,"activeColor":"#15935f","activateTransparency":1,"inactiveColor":"#0a492f","inactiveTransparency":1}|
{"type":"LAYER","ticket":26,"id":"[\\"LAYER\\",25]"}||{"layerId":25,"layerType":"SIGNAL","layerName":"Inner11","use":false,"show":false,"locked":false,"activeColor":"#000080","activateTransparency":1,"inactiveColor":"#000040","inactiveTransparency":1}|
{"type":"LAYER","ticket":27,"id":"[\\"LAYER\\",26]"}||{"layerId":26,"layerType":"SIGNAL","layerName":"Inner12","use":false,"show":false,"locked":false,"activeColor":"#00b400","activateTransparency":1,"inactiveColor":"#005a00","inactiveTransparency":1}|
{"type":"LAYER","ticket":28,"id":"[\\"LAYER\\",27]"}||{"layerId":27,"layerType":"SIGNAL","layerName":"Inner13","use":false,"show":false,"locked":false,"activeColor":"#2e4756","activateTransparency":1,"inactiveColor":"#17232b","inactiveTransparency":1}|
{"type":"LAYER","ticket":29,"id":"[\\"LAYER\\",28]"}||{"layerId":28,"layerType":"SIGNAL","layerName":"Inner14","use":false,"show":false,"locked":false,"activeColor":"#99842f","activateTransparency":1,"inactiveColor":"#4c4217","inactiveTransparency":1}|
{"type":"LAYER","ticket":30,"id":"[\\"LAYER\\",29]"}||{"layerId":29,"layerType":"SIGNAL","layerName":"Inner15","use":false,"show":false,"locked":false,"activeColor":"#ffffaa","activateTransparency":1,"inactiveColor":"#7f7f55","inactiveTransparency":1}|
{"type":"LAYER","ticket":31,"id":"[\\"LAYER\\",30]"}||{"layerId":30,"layerType":"SIGNAL","layerName":"Inner16","use":false,"show":false,"locked":false,"activeColor":"#99842f","activateTransparency":1,"inactiveColor":"#4c4217","inactiveTransparency":1}|
{"type":"LAYER","ticket":32,"id":"[\\"LAYER\\",31]"}||{"layerId":31,"layerType":"SIGNAL","layerName":"Inner17","use":false,"show":false,"locked":false,"activeColor":"#2e4756","activateTransparency":1,"inactiveColor":"#17232b","inactiveTransparency":1}|
{"type":"LAYER","ticket":33,"id":"[\\"LAYER\\",32]"}||{"layerId":32,"layerType":"SIGNAL","layerName":"Inner18","use":false,"show":false,"locked":false,"activeColor":"#3535ff","activateTransparency":1,"inactiveColor":"#1a1a7f","inactiveTransparency":1}|
{"type":"LAYER","ticket":34,"id":"[\\"LAYER\\",33]"}||{"layerId":33,"layerType":"SIGNAL","layerName":"Inner19","use":false,"show":false,"locked":false,"activeColor":"#8000bc","activateTransparency":1,"inactiveColor":"#40005e","inactiveTransparency":1}|
{"type":"LAYER","ticket":35,"id":"[\\"LAYER\\",34]"}||{"layerId":34,"layerType":"SIGNAL","layerName":"Inner20","use":false,"show":false,"locked":false,"activeColor":"#43ae5f","activateTransparency":1,"inactiveColor":"#21572f","inactiveTransparency":1}|
{"type":"LAYER","ticket":36,"id":"[\\"LAYER\\",35]"}||{"layerId":35,"layerType":"SIGNAL","layerName":"Inner21","use":false,"show":false,"locked":false,"activeColor":"#c3ecce","activateTransparency":1,"inactiveColor":"#617667","inactiveTransparency":1}|
{"type":"LAYER","ticket":37,"id":"[\\"LAYER\\",36]"}||{"layerId":36,"layerType":"SIGNAL","layerName":"Inner22","use":false,"show":false,"locked":false,"activeColor":"#728978","activateTransparency":1,"inactiveColor":"#39443c","inactiveTransparency":1}|
{"type":"LAYER","ticket":38,"id":"[\\"LAYER\\",37]"}||{"layerId":37,"layerType":"SIGNAL","layerName":"Inner23","use":false,"show":false,"locked":false,"activeColor":"#39503f","activateTransparency":1,"inactiveColor":"#1c281f","inactiveTransparency":1}|
{"type":"LAYER","ticket":39,"id":"[\\"LAYER\\",38]"}||{"layerId":38,"layerType":"SIGNAL","layerName":"Inner24","use":false,"show":false,"locked":false,"activeColor":"#0c715d","activateTransparency":1,"inactiveColor":"#06382e","inactiveTransparency":1}|
{"type":"LAYER","ticket":40,"id":"[\\"LAYER\\",39]"}||{"layerId":39,"layerType":"SIGNAL","layerName":"Inner25","use":false,"show":false,"locked":false,"activeColor":"#5a8a80","activateTransparency":1,"inactiveColor":"#2d4540","inactiveTransparency":1}|
{"type":"LAYER","ticket":41,"id":"[\\"LAYER\\",40]"}||{"layerId":40,"layerType":"SIGNAL","layerName":"Inner26","use":false,"show":false,"locked":false,"activeColor":"#2b937e","activateTransparency":1,"inactiveColor":"#15493f","inactiveTransparency":1}|
{"type":"LAYER","ticket":42,"id":"[\\"LAYER\\",41]"}||{"layerId":41,"layerType":"SIGNAL","layerName":"Inner27","use":false,"show":false,"locked":false,"activeColor":"#23999d","activateTransparency":1,"inactiveColor":"#114c4e","inactiveTransparency":1}|
{"type":"LAYER","ticket":43,"id":"[\\"LAYER\\",42]"}||{"layerId":42,"layerType":"SIGNAL","layerName":"Inner28","use":false,"show":false,"locked":false,"activeColor":"#45b4e3","activateTransparency":1,"inactiveColor":"#225a71","inactiveTransparency":1}|
{"type":"LAYER","ticket":44,"id":"[\\"LAYER\\",43]"}||{"layerId":43,"layerType":"SIGNAL","layerName":"Inner29","use":false,"show":false,"locked":false,"activeColor":"#215da1","activateTransparency":1,"inactiveColor":"#102e50","inactiveTransparency":1}|
{"type":"LAYER","ticket":45,"id":"[\\"LAYER\\",44]"}||{"layerId":44,"layerType":"SIGNAL","layerName":"Inner30","use":false,"show":false,"locked":false,"activeColor":"#4564d7","activateTransparency":1,"inactiveColor":"#22326b","inactiveTransparency":1}|
{"type":"LAYER","ticket":46,"id":"[\\"LAYER\\",45]"}||{"layerId":45,"layerType":"SIGNAL","layerName":"Inner31","use":false,"show":false,"locked":false,"activeColor":"#6969e9","activateTransparency":1,"inactiveColor":"#343474","inactiveTransparency":1}|
{"type":"LAYER","ticket":47,"id":"[\\"LAYER\\",46]"}||{"layerId":46,"layerType":"SIGNAL","layerName":"Inner32","use":false,"show":false,"locked":false,"activeColor":"#9069e9","activateTransparency":1,"inactiveColor":"#483474","inactiveTransparency":1}|
{"type":"LAYER","ticket":48,"id":"[\\"LAYER\\",47]"}||{"layerId":47,"layerType":"HOLE","layerName":"Hole Layer","use":true,"show":true,"locked":false,"activeColor":"#222222","activateTransparency":0.5,"inactiveColor":"#111111","inactiveTransparency":1}|
{"type":"LAYER","ticket":49,"id":"[\\"LAYER\\",48]"}||{"layerId":48,"layerType":"COMPONENT_SHAPE","layerName":"Component Shape Layer","use":true,"show":true,"locked":false,"activeColor":"#00cccc","activateTransparency":1,"inactiveColor":"#006666","inactiveTransparency":1}|
{"type":"LAYER","ticket":50,"id":"[\\"LAYER\\",49]"}||{"layerId":49,"layerType":"COMPONENT_MARKING","layerName":"Component Marking Layer","use":true,"show":true,"locked":false,"activeColor":"#66ffcc","activateTransparency":1,"inactiveColor":"#337f66","inactiveTransparency":1}|
{"type":"LAYER","ticket":51,"id":"[\\"LAYER\\",50]"}||{"layerId":50,"layerType":"PIN_SOLDERING","layerName":"Pin Soldering Layer","use":true,"show":true,"locked":false,"activeColor":"#cc9999","activateTransparency":1,"inactiveColor":"#664c4c","inactiveTransparency":1}|
{"type":"LAYER","ticket":52,"id":"[\\"LAYER\\",51]"}||{"layerId":51,"layerType":"PIN_FLOATING","layerName":"Pin Floating Layer","use":true,"show":true,"locked":false,"activeColor":"#ff99ff","activateTransparency":1,"inactiveColor":"#7f4c7f","inactiveTransparency":1}|
{"type":"LAYER","ticket":53,"id":"[\\"LAYER\\",52]"}||{"layerId":52,"layerType":"COMPONENT_MODEL","layerName":"Component Model Layer","use":false,"show":false,"locked":false,"activeColor":"#ffffff","activateTransparency":1,"inactiveColor":"#7f7f7f","inactiveTransparency":1}|
{"type":"LAYER","ticket":54,"id":"[\\"LAYER\\",53]"}||{"layerId":53,"layerType":"3D_SHELL_OUTLINE","layerName":"3D Shell Outline Layer","use":true,"show":true,"locked":false,"activeColor":"#66ff99","activateTransparency":1,"inactiveColor":"#337f4c","inactiveTransparency":1}|
{"type":"LAYER","ticket":55,"id":"[\\"LAYER\\",54]"}||{"layerId":54,"layerType":"3D_SHELL_TOP","layerName":"3D Shell Top Layer","use":true,"show":true,"locked":false,"activeColor":"#ffccff","activateTransparency":1,"inactiveColor":"#7f667f","inactiveTransparency":1}|
{"type":"LAYER","ticket":56,"id":"[\\"LAYER\\",55]"}||{"layerId":55,"layerType":"3D_SHELL_BOTTOM","layerName":"3D Shell Bottom Layer","use":true,"show":true,"locked":false,"activeColor":"#0066cc","activateTransparency":1,"inactiveColor":"#003366","inactiveTransparency":1}|
{"type":"LAYER","ticket":57,"id":"[\\"LAYER\\",56]"}||{"layerId":56,"layerType":"DRILL_DRAWING","layerName":"Drill Drawing Layer","use":true,"show":true,"locked":false,"activeColor":"#008080","activateTransparency":1,"inactiveColor":"#004040","inactiveTransparency":1}|
{"type":"LAYER","ticket":58,"id":"[\\"LAYER\\",57]"}||{"layerId":57,"layerType":"OTHER","layerName":"Ratline Layer","use":true,"show":true,"locked":true,"activeColor":"#6464ff","activateTransparency":1,"inactiveColor":"#32327f","inactiveTransparency":1}|
{"type":"LAYER","ticket":59,"id":"[\\"LAYER\\",58]"}||{"layerId":58,"layerType":"TOP_STIFFENER","layerName":"Top Stiffener Layer","use":false,"show":false,"locked":false,"activeColor":"#eee666","activateTransparency":1,"inactiveColor":"#777333","inactiveTransparency":1}|
{"type":"LAYER","ticket":60,"id":"[\\"LAYER\\",59]"}||{"layerId":59,"layerType":"BOTTOM_STIFFENER","layerName":"Bottom Stiffener Layer","use":false,"show":false,"locked":false,"activeColor":"#ccff00","activateTransparency":1,"inactiveColor":"#667f00","inactiveTransparency":1}|
{"type":"LAYER","ticket":61,"id":"[\\"LAYER\\",361]"}||{"layerId":361,"layerType":"SUBSTRATE","layerName":"Dielectric1","use":false,"show":false,"locked":false,"activeColor":"#000000","activateTransparency":0,"inactiveColor":"#000000","inactiveTransparency":1}|
{"type":"LAYER","ticket":62,"id":"[\\"LAYER\\",362]"}||{"layerId":362,"layerType":"SUBSTRATE","layerName":"Dielectric2","use":false,"show":false,"locked":false,"activeColor":"#000000","activateTransparency":0,"inactiveColor":"#000000","inactiveTransparency":1}|
{"type":"LAYER","ticket":63,"id":"[\\"LAYER\\",363]"}||{"layerId":363,"layerType":"SUBSTRATE","layerName":"Dielectric3","use":false,"show":false,"locked":false,"activeColor":"#000000","activateTransparency":0,"inactiveColor":"#000000","inactiveTransparency":1}|
{"type":"LAYER","ticket":64,"id":"[\\"LAYER\\",364]"}||{"layerId":364,"layerType":"SUBSTRATE","layerName":"Dielectric4","use":false,"show":false,"locked":false,"activeColor":"#000000","activateTransparency":0,"inactiveColor":"#000000","inactiveTransparency":1}|
{"type":"LAYER","ticket":65,"id":"[\\"LAYER\\",365]"}||{"layerId":365,"layerType":"SUBSTRATE","layerName":"Dielectric5","use":false,"show":false,"locked":false,"activeColor":"#000000","activateTransparency":0,"inactiveColor":"#000000","inactiveTransparency":1}|
{"type":"ACTIVE_LAYER","ticket":83,"id":"ACTIVE_LAYER"}||{"layerId":1}|
{"type":"RULE_TEMPLATE","ticket":84,"id":"RULE_TEMPLATE"}||{"name":"自定义配置"}|
{"type":"RULE","ticket":85,"id":"[\\"RULE\\",\\"SAFE\\",\\"copperThickness1oz\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","isForAll":"ALL","safeSpacing":[{"layerId":1,"isOpen":true,"content":[[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0]],"columnNames":[]}]}}|
{"type":"RULE","ticket":86,"id":"[\\"RULE\\",\\"SAFE\\",\\"copperThickness2oz\\"]"}||{"ruleState":"NORMAL","ruleContext":{"unit":"mil","isForAll":"ALL","safeSpacing":[{"layerId":1,"isOpen":true,"content":[[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0]],"columnNames":[]}]}}|
{"type":"RULE","ticket":87,"id":"[\\"RULE\\",\\"SAFE\\",\\"copperThicknessInner0.5oz\\"]"}||{"ruleState":"NORMAL","ruleContext":{"unit":"mil","isForAll":"ALL","safeSpacing":[{"layerId":1,"isOpen":true,"content":[[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0]],"columnNames":[]}]}}|
{"type":"RULE","ticket":88,"id":"[\\"RULE\\",\\"OTHER\\",\\"otherClearance\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","deviceClearance":0,"thru2SmdClearance":0,"holeClearance":0}}|
{"type":"RULE","ticket":89,"id":"[\\"RULE\\",\\"TRACK\\",\\"copperThickness1oz\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","track":{"isOpen":true,"content":[{"layerId":1,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":2,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":15,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":16,"stroMin":1,"stroDef":10,"stroMax":100}]}}}|
{"type":"RULE","ticket":90,"id":"[\\"RULE\\",\\"TRACK\\",\\"copperThickness2oz\\"]"}||{"ruleState":"NORMAL","ruleContext":{"unit":"mil","track":{"isOpen":true,"content":[{"layerId":1,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":2,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":15,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":16,"stroMin":1,"stroDef":10,"stroMax":100}]}}}|
{"type":"RULE","ticket":91,"id":"[\\"RULE\\",\\"TRACK\\",\\"copperThickness0.5oz\\"]"}||{"ruleState":"NORMAL","ruleContext":{"unit":"mil","track":{"isOpen":true,"content":[{"layerId":1,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":2,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":15,"stroMin":1,"stroDef":10,"stroMax":100},{"layerId":16,"stroMin":1,"stroDef":10,"stroMax":100}]}}}|
{"type":"RULE","ticket":92,"id":"[\\"RULE\\",\\"NET_LENGTH\\",\\"netLength\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","netLenMin":0,"netLenMax":0}}|
{"type":"RULE","ticket":93,"id":"[\\"RULE\\",\\"NET_LENGTH_TOLERANCE\\",\\"netLengthTolerance\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","netLengthTolerance":1000}}|
{"type":"RULE","ticket":94,"id":"[\\"RULE\\",\\"DIFFER_ENTAIL\\",\\"differentialPair\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","stroWidth":{"isOpen":true,"content":[{"layerId":1,"stroMin":5,"stroMax":100,"stroDef":10}]},"spacing":{"isOpen":true,"content":[{"layerId":1,"spacMin":5.9843,"spacDef":5.9843}]},"differPairLenTolerMax":10}}|
{"type":"RULE","ticket":95,"id":"[\\"RULE\\",\\"BLIND\\",\\"blindVia\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"blinds":{"content":[]}}}|
{"type":"RULE","ticket":96,"id":"[\\"RULE\\",\\"RADIUS\\",\\"viaSize\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","minRadius":0.5,"defRadius":12.0079,"maxRadius":196.8504,"minInner":0.5,"defInner":6.0039,"maxInner":124.0158}}|
{"type":"RULE","ticket":97,"id":"[\\"RULE\\",\\"PLANE\\",\\"innerPlane\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","mulPad":{"isOpen":true,"content":[{"layerId":1,"connType":"DIVERGENCE","spoSpac":10,"spoWidth":10,"spoAng":90}]}}}|
{"type":"RULE","ticket":98,"id":"[\\"RULE\\",\\"COPPER\\",\\"copperRegion\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","sglPad":{"isOpen":true,"content":[{"layerId":1,"connType":"DIRECT","spoSpac":10,"spoWidth":10,"spoAng":90},{"layerId":2,"connType":"DIRECT","spoSpac":10,"spoWidth":10,"spoAng":90}]},"mulPad":{"isOpen":true,"content":[{"layerId":1,"connType":"DIRECT","spoSpac":10,"spoWidth":10,"spoAng":90},{"layerId":2,"connType":"DIRECT","spoSpac":10,"spoWidth":10,"spoAng":90},{"layerId":15,"connType":"DIRECT","spoSpac":10,"spoWidth":10,"spoAng":90},{"layerId":16,"connType":"DIRECT","spoSpac":10,"spoWidth":10,"spoAng":90}]},"track":{"isOpen":true,"content":[{"layerId":1,"connType":"DIRECT"},{"layerId":2,"connType":"DIRECT"},{"layerId":15,"connType":"DIRECT"},{"layerId":16,"connType":"DIRECT"}]}}}|
{"type":"RULE","ticket":99,"id":"[\\"RULE\\",\\"PASTE\\",\\"pasteMaskExpansion\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","padTopExpan":0,"padBotExpan":0,"testPointTopExpan":-1000,"testPointBotExpan":-1000}}|
{"type":"RULE","ticket":100,"id":"[\\"RULE\\",\\"SOLDER\\",\\"solderMaskExpansion\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"unit":"mil","padTopExpan":2.0079,"padBotExpan":2.0079,"viaTopExpan":-1000,"viaBotExpan":-1000,"testPointTopExpan":2.0079,"testPointBotExpan":2.0079}}|
{"type":"RULE","ticket":101,"id":"[\\"RULE\\",\\"AUTO_ROUTER\\",\\"Common\\"]"}||{"ruleState":"DEFAULT","ruleContext":{"routingCorner":"L45","isKeep":1,"viaQuantity":"LESS","routingEffectPriority":"COMPLETION_FIRST","layers":[1,2,12],"ignoreNets":[]}}|
{"type":"PRIMITIVE","ticket":102,"id":"[\\"PRIMITIVE\\",\\"ALL\\"]"}||{"display":true,"pick":false}|
{"type":"PRIMITIVE","ticket":103,"id":"[\\"PRIMITIVE\\",\\"COMPONENT\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":104,"id":"[\\"PRIMITIVE\\",\\"PROPERTY\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":105,"id":"[\\"PRIMITIVE\\",\\"COMPONENTSILK\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":106,"id":"[\\"PRIMITIVE\\",\\"TRACK\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":107,"id":"[\\"PRIMITIVE\\",\\"VIA\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":108,"id":"[\\"PRIMITIVE\\",\\"TESTPOINT\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":109,"id":"[\\"PRIMITIVE\\",\\"PAD\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":110,"id":"[\\"PRIMITIVE\\",\\"PADSPAIR\\"]"}||{"display":true,"pick":false}|
{"type":"PRIMITIVE","ticket":111,"id":"[\\"PRIMITIVE\\",\\"NETWORK\\"]"}||{"display":true,"pick":false}|
{"type":"PRIMITIVE","ticket":112,"id":"[\\"PRIMITIVE\\",\\"SUTUREHOLE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":113,"id":"[\\"PRIMITIVE\\",\\"TEARDROP\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":114,"id":"[\\"PRIMITIVE\\",\\"RATLINE\\"]"}||{"display":false,"pick":false}|
{"type":"PRIMITIVE","ticket":115,"id":"[\\"PRIMITIVE\\",\\"GROUP\\"]"}||{"display":true,"pick":false}|
{"type":"PRIMITIVE","ticket":116,"id":"[\\"PRIMITIVE\\",\\"TEXT\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":117,"id":"[\\"PRIMITIVE\\",\\"IMAGE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":118,"id":"[\\"PRIMITIVE\\",\\"PICTURE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":119,"id":"[\\"PRIMITIVE\\",\\"DIMENSION\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":120,"id":"[\\"PRIMITIVE\\",\\"BOARDOUTLINE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":121,"id":"[\\"PRIMITIVE\\",\\"SLOTREGION\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":122,"id":"[\\"PRIMITIVE\\",\\"FILLREGIEN\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":123,"id":"[\\"PRIMITIVE\\",\\"COPPEROUTLINE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":124,"id":"[\\"PRIMITIVE\\",\\"COPPERFILLED\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":125,"id":"[\\"PRIMITIVE\\",\\"PROHIBITEDREGION\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":126,"id":"[\\"PRIMITIVE\\",\\"CONSTRAINT\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":127,"id":"[\\"PRIMITIVE\\",\\"PARTITION\\"]"}||{"display":false,"pick":false}|
{"type":"PRIMITIVE","ticket":128,"id":"[\\"PRIMITIVE\\",\\"LINE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":129,"id":"[\\"PRIMITIVE\\",\\"LOCKED\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":130,"id":"[\\"PRIMITIVE\\",\\"UNLOCKED\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":131,"id":"[\\"PRIMITIVE\\",\\"SHELL\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":132,"id":"[\\"PRIMITIVE\\",\\"BOSS\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":133,"id":"[\\"PRIMITIVE\\",\\"CREASE\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":134,"id":"[\\"PRIMITIVE\\",\\"TOPSHELLCUT\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":135,"id":"[\\"PRIMITIVE\\",\\"SIDESHELLCUT\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":136,"id":"[\\"PRIMITIVE\\",\\"TOPBOTTOMENTITY\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":137,"id":"[\\"PRIMITIVE\\",\\"SIDEENTITY\\"]"}||{"display":true,"pick":true}|
{"type":"PRIMITIVE","ticket":138,"id":"[\\"PRIMITIVE\\",\\"FPC_STIFFENER\\"]"}||{"display":true,"pick":true}|
{"type":"SILK_OPTS","ticket":139,"id":"[\\"SILK_OPTS\\",3]"}||{"defaultColor":"#000000","baseColor":"#FFFFFF"}|
{"type":"SILK_OPTS","ticket":140,"id":"[\\"SILK_OPTS\\",4]"}||{"defaultColor":"#000000","baseColor":"#FFFFFF"}|
{"type":"PREFERENCE","ticket":141,"id":"PREFERENCE"}||{"startTrackWidthFollowLast":false,"lastTrackWidth":10,"startViaSizeFollowLast":false,"lastViaInnerDiameter":12.0078,"lastViaDiameter":24.0158,"snap":true,"routingMode":"SURROUND","routingCorner":"L45","removeLoop":true,"rotatingObject":false,"trackFollow":true,"stretchTrackMinCorner":1,"preferenceConfig":"JLC06161H-3313","realTimeUpdateUnusedLayers":false,"unusedPadRange":"VIA","pushVia":"OPTIMIZA_OPEN","pathOptimization4BePushed":"SINGLE","currentPathOptimization4BePushed":"OPTIMIZA_WEAK","removeCircuitsContainingVias":true,"removeAntenna":true}|
{"type":"PANELIZE","ticket":142,"id":"PANELIZE"}||{"on":false,"row":1,"column":1,"rowSpacing":0,"columnSpacing":0,"onlyOutline":true,"horizontalStamp":{"on":false,"stampHoleGroupQuantity":1,"stampHoleDiameter":21.6535,"stampHoleQuantityPerGroup":8,"stampHoleSpacing":33.4646},"verticalStamp":{"on":false,"stampHoleGroupQuantity":1,"stampHoleDiameter":21.6535,"stampHoleQuantityPerGroup":8,"stampHoleSpacing":33.4646},"horizontalSize":{"on":false,"sideHeight":236.2205,"positionHoleDiameter":78.7402,"markDiameter":39.3701,"markExpansion":19.685},"verticalSize":{"on":true,"sideHeight":236.2205,"positionHoleDiameter":78.7402,"markDiameter":39.3701,"markExpansion":19.685}}`.trim();

    // 原始图层数据定义 ["类型", 层ID, "类型", "别名", 状态, "激活颜色", 激活透明度, "非激活颜色", 非激活透明度]
    const rawLayerData = [
        ["LAYER",1,"TOP","Top Layer",3,"#cc6633",1,"#7f0000",0.5],
        ["LAYER",2,"BOTTOM","Bottom Layer",3,"#6699ff",1,"#00007f",0.5],
        ["LAYER",3,"TOP_SILK","Top Silkscreen Layer",3,"#ffcc00",0.8,"#7f6600",0.5],
        ["LAYER",4,"BOT_SILK","Bottom Silkscreen Layer",3,"#66cc33",0.8,"#336619",0.5],
        ["LAYER",5,"TOP_SOLDER_MASK","Top Solder Mask Layer",3,"#800080",0.2,"#400040",0.5],
        ["LAYER",6,"BOT_SOLDER_MASK","Bottom Solder Mask Layer",3,"#aa00ff",0.2,"#55007f",0.5],
        ["LAYER",7,"TOP_PASTE_MASK","Top Paste Mask Layer",3,"#808080",0.2,"#404040",0.5],
        ["LAYER",8,"BOT_PASTE_MASK","Bottom Paste Mask Layer",3,"#800000",0.2,"#400000",0.5],
        ["LAYER",9,"TOP_ASSEMBLY","Top Assembly Layer",3,"#33cc99",0.5,"#19664c",0.5],
        ["LAYER",10,"BOT_ASSEMBLY","Bottom Assembly Layer",3,"#5555ff",0.5,"#2a2a7f",0.5],
        ["LAYER",11,"OUTLINE","Board Outline Layer",3,"#ff00ff",1,"#7f007f",0.5],
        ["LAYER",12,"MULTI","Multi-Layer",3,"#c0c0c0",0.7,"#606060",0.5],
        ["LAYER",13,"DOCUMENT","Document Layer",3,"#ffffff",0.7,"#7f7f7f",0.5],
        ["LAYER",14,"MECHANICAL","Mechanical Layer",3,"#f022f0",0.7,"#781178",0.5],
        ["LAYER",15,"SIGNAL","Inner1",3,"#999966",1,"#4c4c33",0.5],
        ["LAYER",16,"SIGNAL","Inner2",3,"#0099cc",1,"#004000",0.5],
        ["LAYER",17,"SIGNAL","Inner3",3,"#339999",1,"#007f00",0.5],
        ["LAYER",18,"SIGNAL","Inner4",3,"#bc8e00",1,"#5e4700",0.5],
        ["LAYER",19,"SIGNAL","Inner5",0,"#70dbfa",1,"#386d7d",0.5],
        ["LAYER",20,"SIGNAL","Inner6",0,"#00cc66",1,"#006633",0.5],
        ["LAYER",21,"SIGNAL","Inner7",0,"#9966ff",1,"#4c337f",0.5],
        ["LAYER",22,"SIGNAL","Inner8",0,"#800080",1,"#400040",0.5],
        ["LAYER",23,"SIGNAL","Inner9",0,"#008080",1,"#004040",0.5],
        ["LAYER",24,"SIGNAL","Inner10",0,"#15935f",1,"#a492f",0.5],
        ["LAYER",25,"SIGNAL","Inner11",0,"#000080",1,"#000040",0.5],
        ["LAYER",26,"SIGNAL","Inner12",0,"#00b400",1,"#005a00",0.5],
        ["LAYER",27,"SIGNAL","Inner13",0,"#2e4756",1,"#17232b",0.5],
        ["LAYER",28,"SIGNAL","Inner14",0,"#99842f",1,"#4c4217",0.5],
        ["LAYER",29,"SIGNAL","Inner15",0,"#ffffaa",1,"#7f7f55",0.5],
        ["LAYER",30,"SIGNAL","Inner16",0,"#99842f",1,"#4c4217",0.5],
        ["LAYER",31,"SIGNAL","Inner17",0,"#2e4756",1,"#17232b",0.5],
        ["LAYER",32,"SIGNAL","Inner18",0,"#3535ff",1,"#1a1a7f",0.5],
        ["LAYER",33,"SIGNAL","Inner19",0,"#8000bc",1,"#40005e",0.5],
        ["LAYER",34,"SIGNAL","Inner20",0,"#43ae5f",1,"#21572f",0.5],
        ["LAYER",35,"SIGNAL","Inner21",0,"#c3ecce",1,"#617667",0.5],
        ["LAYER",36,"SIGNAL","Inner22",0,"#728978",1,"#39443c",0.5],
        ["LAYER",37,"SIGNAL","Inner23",0,"#39503f",1,"#1c281f",0.5],
        ["LAYER",38,"SIGNAL","Inner24",0,"#0c715d",1,"#06382e",0.5],
        ["LAYER",39,"SIGNAL","Inner25",0,"#5a8a80",1,"#2d4540",0.5],
        ["LAYER",40,"SIGNAL","Inner26",0,"#2b937e",1,"#15493f",0.5],
        ["LAYER",41,"SIGNAL","Inner27",0,"#23999d",1,"#114c4e",0.5],
        ["LAYER",42,"SIGNAL","Inner28",0,"#45b4e3",1,"#225a71",0.5],
        ["LAYER",43,"SIGNAL","Inner29",0,"#215da1",1,"#102e50",0.5],
        ["LAYER",44,"SIGNAL","Inner30",0,"#4564d7",1,"#22326b",0.5],
        ["LAYER",45,"SIGNAL","Inner31",0,"#6969e9",1,"#343474",0.5],
        ["LAYER",46,"SIGNAL","Inner32",0,"#9069e9",1,"#483474",0.5],
        ["LAYER",47,"HOLE","Hole Layer",3,"#222222",1,"#111111",0.5],
        ["LAYER",48,"COMPONENT_SHAPE","Component Shape Layer",1,"#00cccc",1,"#006666",0.5],
        ["LAYER",49,"COMPONENT_MARKING","Component Marking Layer",1,"#66ffcc",1,"#337f66",0.5],
        ["LAYER",50,"PIN_SOLDERING","Pin Soldering Layer",1,"#cc9999",1,"#664c4c",0.5],
        ["LAYER",51,"PIN_FLOATING","Pin Floating Layer",1,"#ff99ff",1,"#7f4c7f",0.5],
        ["LAYER",52,"COMPONENT_MODEL","Component Model Layer",0,"#ffffff",1,"#7f7f7f",0.5],
        ["LAYER",53,"3D_SHELL_OUTLINE","3D Shell Outline Layer",3,"#66ff99",1,"#337f4c",0.5],
        ["LAYER",54,"3D_SHELL_TOP","3D Shell Top Layer",3,"#ffccff",1,"#7f667f",0.5],
        ["LAYER",55,"3D_SHELL_BOTTOM","3D Shell Bottom Layer",3,"#0066cc",1,"#003366",0.5],
        ["LAYER",56,"DRILL_DRAWING","Drill Drawing Layer",3,"#008080",1,"#004040",0.5],
        ["LAYER",57,"OTHER","Ratline Layer",7,"#6464ff",1,"#32327f",0.5],
        ["LAYER",58,"TOP_STIFFENER","Top Stiffener Layer",0,"#eee666",1,"#777333",0.5],
        ["LAYER",59,"BOTTOM_STIFFENER","Bottom Stiffener Layer",0,"#ccff00",1,"#667f00",0.5],
        // --- [新增] 内部专用图元图层 (ID 500+) ---
        ["LAYER",500,"DRILL_PTH","PTH Through",3,"#222222",1,"#666666",0.5],          // 金属化通孔
        ["LAYER",501,"DRILL_NPTH","NPTH Through",3,"#222222",1,"#7f4c00",0.5],        // 非金属化通孔
        ["LAYER",502,"DRILL_BLIND","Blind/Buried Via",3,"#cccccc",0.5,"#007f7f",0.5]  // 埋盲孔
    ];

    // 添加自定义层 (71-100)
    for(let i=71; i<=100; i++) {
        const color = rawLayerData.find(d => d[1] === (i-71+46))?.[5] || "#888888"; // 简单回退颜色
        rawLayerData.push(["LAYER", i, "CUSTOM", `自定义${i-70}`, 0, color, 1, color, 0.5]);
    }

    // 中文名称映射表
    const cnNames = {
        1: "顶层线路", 
        2: "底层线路", 
        3: "顶层丝印", 
        4: "底层丝印", 
        5: "顶层阻焊", 
        6: "底层阻焊", 
        7: "顶层锡膏", 
        8: "底层锡膏", 
        9: "顶层装配", 
        10: "底层装配",
        11: "板框层", 
        12: "多层", 
        13: "文档层", 
        14: "机械层",
        47: "钻孔层", 
        57: "其他",
        48: "元件形状层",
        49: "元件标记层",
        50: "引脚焊接层",
        51: "引脚浮动层",
        52: "元件模型层",
        53: "3D外壳边框层",
        54: "3D外壳顶层",
        55: "3D外壳底层",
        56: "钻孔图层",
        58: "顶部补强层(FPC)",
        59: "底部补强板(FPC)",
        500: "金属化通孔",
        501: "非金属化通孔",
        502: "埋盲孔"
    };
    
    // 初始化 layerDefs
    const layerDefs = {};
    const layerIdMap = {};
    
    // 对图层名称进行汉化处理
    rawLayerData.forEach(item => {
        const id = item[1];
        let name = cnNames[id] || item[3]; // 优先使用中文名，否则用英文
        if (id >= 15 && id <= 46) name = item[3].replace("Inner", "内层"); // 内层汉化

        layerDefs[id] = {
            name: name,
            color: item[5], // 第6个参数
            alpha: item[6]  // 第7个参数
        };
        layerIdMap[id] = name;
    });

    // 定义分组显示结构
    const uiGroups = [
        { 
            id: "TOP", name: "顶面", 
            ids: [1, 3, 5, 7, 9, 58] 
        },
        { 
            id: "BOTTOM", name: "底面", 
            ids: [2, 4, 6, 8, 10, 59] 
        },
        { 
            id: "INNER", name: "内层", 
            ids: [] // 自动填充 15-46
        },
        { 
            id: "OTHER", name: "多层/钻孔", 
            // [修改] 添加 500, 501, 502
            ids: [11, 12, 47, 500, 501, 502] 
        },
        {
            id: "CUSTOM", name: "自定义/特殊",
            ids: [] // 自动填充剩余
        }
    ];

    // 填充内层
    for(let i=15; i<=46; i++) uiGroups[2].ids.push(i);

    // 填充其余未归类的层到“自定义/特殊”
    const allGroupedIds = new Set(uiGroups.flatMap(g => g.ids));
    rawLayerData.forEach(item => {
        if(!allGroupedIds.has(item[1]) && item[1] !== 47) {
             uiGroups[4].ids.push(item[1]);
        }
    });
    
    // --- 文件名匹配规则 (重构版：优先全名，后备扩展名) ---
    const fileNameRules = [];

    // 1. EasyEDA/立创EDA 导出文件名格式
    const easyEdaRules = [
        { regex: /Gerber_TopLayer/i, layerId: 1 },                // 顶层
        { regex: /Gerber_BottomLayer/i, layerId: 2 },             // 底层
        { regex: /Gerber_TopSilkscreenLayer/i, layerId: 3 },      // 顶层丝印
        { regex: /Gerber_BottomSilkscreenLayer/i, layerId: 4 },   // 底层丝印
        { regex: /Gerber_TopSolderMaskLayer/i, layerId: 5 },      // 顶层阻焊
        { regex: /Gerber_BottomSolderMaskLayer/i, layerId: 6 },   // 底层阻焊
        { regex: /Gerber_TopPasteMaskLayer/i, layerId: 7 },       // 顶层锡膏
        { regex: /Gerber_BottomPasteMaskLayer/i, layerId: 8 },    // 底层锡膏
        { regex: /Gerber_TopAssemblyLayer/i, layerId: 9 },        // 顶层装配
        { regex: /Gerber_BottomAssemblyLayer/i, layerId: 10 },    // 底层装配
        { regex: /Gerber_BoardOutlineLayer/i, layerId: 11 },      // 板框
        { regex: /Gerber_MechanicalLayer/i, layerId: 14 },        // 机械层
        { regex: /Gerber_DocumentLayer/i, layerId: 13 },          // 文档层
        { regex: /Gerber_DrillDrawingLayer/i, layerId: 56 },      // 钻孔图层

        // --- [新增] 细分钻孔匹配规则 ---
        // 使用 ID 500+
        { regex: /Drill_PTH_Through/i, layerId: 500 },            // 金属化钻孔
        { regex: /Drill_NPTH_Through/i, layerId: 501 },           // 非金属化钻孔
        { regex: /Drill_.*_to_.*/i, layerId: 502 },               // 埋盲孔钻孔
        
        // --- [原有] 通用兜底规则 ---
        { regex: /Drill_PTH/i, layerId: 47 },                     
        { regex: /Drill_NPTH/i, layerId: 47 },                    
        { regex: /Drill_Through/i, layerId: 47 }
    ];
    
    // 动态添加 EasyEDA Pro 内层规则 (Gerber_InnerLayer1.G1 -> ID 15)
    for (let i = 1; i <= 32; i++) {
        // 这里的正则变成了 /Gerber_InnerLayer1\./i
        // 这样它只能匹配 "Gerber_InnerLayer1.G1"，而无法匹配 "Gerber_InnerLayer10.G10"
        easyEdaRules.push({ 
            regex: new RegExp(`Gerber_InnerLayer${i}\\.`, 'i'), 
            layerId: 14 + i 
        });
    }

    // 2. 【新增】自定义下划线命名规则 (匹配 xxx_copper_top.gbr 等)
    const customPatternRules = [
        { regex: /_copper_top\.gbr$/i, layerId: 1 },         // 顶层线路
        { regex: /_copper_bottom\.gbr$/i, layerId: 2 },      // 底层线路
        
        { regex: /_silkscreen_top\.gbr$/i, layerId: 3 },     // 顶层丝印
        { regex: /_silkscreen_bottom\.gbr$/i, layerId: 4 },  // 底层丝印
        
        { regex: /_soldermask_top\.gbr$/i, layerId: 5 },     // 顶层阻焊
        { regex: /_soldermask_bottom\.gbr$/i, layerId: 6 },  // 底层阻焊
        
        { regex: /_smdmask_top\.gbr$/i, layerId: 7 },        // 顶层助焊/钢网
        { regex: /_smdmask_bottom\.gbr$/i, layerId: 8 },     // 底层助焊/钢网
        
        { regex: /_outline\.gbr$/i, layerId: 11 },           // 板框
        
        // 钻孔文件直接匹配扩展名 .drl (对应你的 xxx.drl)
        { regex: /\.drl$/i, layerId: 47 } 
    ];


    // 3. 【低优先级】通用扩展名兜底
    // 如果文件名不匹配上面的特定格式，则尝试通过扩展名识别
    const extensionRules = [
        { regex: /\.GTL$/i, layerId: 1 }, 
        { regex: /\.GBL$/i, layerId: 2 },
        { regex: /\.GTO$/i, layerId: 3 }, 
        { regex: /\.GBO$/i, layerId: 4 },
        { regex: /\.GTS$/i, layerId: 5 }, 
        { regex: /\.GBS$/i, layerId: 6 },
        { regex: /\.GTP$/i, layerId: 7 }, 
        { regex: /\.GBP$/i, layerId: 8 },
        { regex: /\.GTA$/i, layerId: 9 }, 
        { regex: /\.GBA$/i, layerId: 10 },
        { regex: /\.GKO$|\.GM1$|\.GML$|\.OUT$/i, layerId: 11 },
        { regex: /\.GME$/i, layerId: 14 },
        { regex: /\.GDL$/i, layerId: 13 },
        { regex: /\.GDD$/i, layerId: 56 },
        { regex: /\.DRL$|\.TXT$|\.XY$|\.XLN$/i, layerId: 47 } // 常见钻孔扩展名
    ];

    // 动态添加通用内层扩展名 (.G1, .G2, .GP1, .IN1 等)
    for (let i = 1; i <= 32; i++) {
        extensionRules.push({ 
            // 匹配 .G1, .G10, .GP1 等，依靠 $ 确保是结尾，避免 .G1 匹配 .G10
            regex: new RegExp(`\\.G${i}$|\\.GP${i}$|\\.IN${i}$`, 'i'), 
            layerId: 14 + i 
        });
    }

    // 合并规则：高优先级在前，数组 find 方法会返回第一个匹配项
    fileNameRules.push(...easyEdaRules, ...customPatternRules, ...extensionRules);

// ====================================================================================
// 2. 全局状态定义
// ====================================================================================

    let rawFilesCache = []; 
    let loadedFiles = [];
    let viewState = { scale: 15, offsetX: 0, offsetY: 0, unit: 'mm', isDragging: false, lastX: 0, lastY: 0 };
    // --- 5. 画布渲染 (优化版：HiDPI + RAF 节流) ---
    const mainCanvas = document.getElementById('main-canvas');
    const ctx = mainCanvas.getContext('2d', { alpha: false }); // 优化：关闭透明通道
    const rulerH = document.getElementById('ruler-h'); const ctxH = rulerH.getContext('2d');
    const rulerV = document.getElementById('ruler-v'); const ctxV = rulerV.getContext('2d');

    const bufferCanvas = document.createElement('canvas');
    const bufCtx = bufferCanvas.getContext('2d', { willReadFrequently: true });

    let isRenderPending = false; // RAF 锁

// ====================================================================================
// 3. 核心解析器 (Parser)
// ====================================================================================

    // Gerber 解析器核心 (支持 EasyEDA Pro 宏名称与 Drill Drawing)
    class GerberParser {
        constructor() { this.reset(); }
        
        reset() {
            this.apertures = {}; 
            this.macros = {}; // <--- [新增] 用于存储宏定义
            this.commands = [];
            this.state = { 
                x: 0, y: 0, 
                dCode: null, apertureCode: null, 
                format: { xInt:2, xDec:4, divX:10000, yInt:2, yDec:4, divY:10000 }, 
                units: 'mm',
                isRegion: false,
                regionPath: [], 
                interpolationMode: 1, 
                isDrill: false,
                polarity: 'D' 
            };
            this.bounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
        }

        parse(content, configOverride) {
            this.reset();
            
            if (content.indexOf('M48') !== -1 || (content.indexOf('T0') !== -1 && content.indexOf('D0') === -1)) {
                this.state.isDrill = true;
            }

            if (configOverride) {
                if (this.state.isDrill) {
                    // 如果是钻孔文件，且设置了钻孔单位，则应用
                    if (configOverride.drillUnits && configOverride.drillUnits !== 'auto') {
                        this.state.units = configOverride.drillUnits;
                    }
                } else {
                    // 否则应用图形单位
                    if (configOverride.units && configOverride.units !== 'auto') {
                        this.state.units = configOverride.units;
                    }
                }
                
                let intVal = 2;
                let decVal = 4;

                if (this.state.isDrill) {
                    // 如果是钻孔文件，应用钻孔参数
                    if (configOverride.dInt) intVal = configOverride.dInt;
                    if (configOverride.dDec) decVal = configOverride.dDec;
                } else {
                    // 如果是图形文件，应用图形参数
                    if (configOverride.gInt) intVal = configOverride.gInt;
                    if (configOverride.gDec) decVal = configOverride.gDec;
                }

                const div = Math.pow(10, decVal);
                this.state.format.xInt = intVal; this.state.format.yInt = intVal;
                this.state.format.xDec = decVal; this.state.format.yDec = decVal;
                this.state.format.divX = div; this.state.format.divY = div;
            }

            let cleanContent = content.replace(/[\r\n]+/g, '\n');
            // 匹配 %AMName*Content*% 格式，非贪婪匹配
            const amRegex = /%AM(\w+)\*([^%]+)%/g;
            let amMatch;
            while ((amMatch = amRegex.exec(cleanContent)) !== null) {
                const macroName = amMatch[1];
                const macroBody = amMatch[2]; // 获取 * 和 * 之间的内容
                
                // 处理数据：将换行去掉，将星号转为逗号（有些Gerber用*分隔参数）
                const cleanBody = macroBody.replace(/[\n\r]/g, '').replace(/\*/g, ',');
                const params = cleanBody.split(',').map(Number);
                
                // 仅处理 Primitive 4 (Polygon)
                // 格式: 4, Exposure, PointCount, x1, y1, ...
                if (params[0] === 4) {
                    const count = params[2];
                    const points = [];
                    for (let i = 0; i < count; i++) {
                        const idx = 3 + (i * 2);
                        if (idx + 1 < params.length) {
                            points.push({ x: params[idx], y: params[idx+1] });
                        }
                    }
                    // 存入 macros
                    this.macros[macroName] = { type: 'POLYGON', points: points };
                }
            }
            cleanContent = cleanContent.replace(/(G36|G37)/g, '\n$1\n'); 
            const lines = cleanContent.split(/[*\n]/); 

            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                if (line.startsWith('%')) this.handleExt(line, configOverride); 
                else this.handleStd(line, configOverride);
            }
            return { 
                commands: this.commands, 
                apertures: this.apertures, 
                macros: this.macros, // <--- [新增]
                bounds: this.bounds, 
                units: this.state.units 
            };
        }

        handleExt(line, config) {
            line = line.replace(/%/g, '');
            
            // --- [核心修复] ---
            // 旧代码检查的是 config.int，但实际上传入的是 config.gInt 或 config.dInt
            // 只要 config 中存在任意一种手动指定的参数，就忽略文件内部的格式定义
            const ignoreFileFormat = config && (
                config.gInt !== undefined || 
                config.gDec !== undefined || 
                config.dInt !== undefined || 
                config.dDec !== undefined
            );
            
            if (line.startsWith('LPD')) this.state.polarity = 'D'; 
            if (line.startsWith('LPC')) this.state.polarity = 'C'; 

            // 如果 ignoreFileFormat 为 true，则跳过 %FS 解析，保留手动设置的参数
            if (line.startsWith('FS') && !ignoreFileFormat) {
                const mX = line.match(/X(\d)(\d)/), mY = line.match(/Y(\d)(\d)/);
                if (mX) { this.state.format.xDec = parseInt(mX[2]); this.state.format.divX = Math.pow(10, this.state.format.xDec); }
                if (mY) { this.state.format.yDec = parseInt(mY[2]); this.state.format.divY = Math.pow(10, this.state.format.yDec); }
            }
            if (line.startsWith('MO')) {
                // 如果 config 指定了 units (非 auto)，则忽略文件内部单位设置
                if (!config || config.units === 'auto') {
                    this.state.units = line.includes('IN') ? 'in' : 'mm';
                }
            }
            // --- [新增] 解析 AM (Aperture Macro) ---
            if (line.startsWith('AM')) {
                // 格式示例: AMPolygonMacro1*4,1,6,x1,y1,x2,y2...
                const parts = line.split('*');
                if (parts.length >= 2) {
                    const macroName = parts[0].substring(2); // 去掉 'AM'
                    const macroBody = parts[1]; // 获取数据部分 "4,1,6,..."
                    
                    // 解析数据
                    const params = macroBody.split(',').map(Number);
                    
                    // 仅处理 Primitive 4 (Polygon)
                    // 格式: 4, Exposure, NumPoints, x1, y1, ...
                    if (params[0] === 4) {
                        const count = params[2];
                        const points = [];
                        for (let i = 0; i < count; i++) {
                            // 点坐标从索引 3 开始，每两个一组 (x, y)
                            const idx = 3 + (i * 2);
                            if (idx + 1 < params.length) {
                                points.push({ x: params[idx], y: params[idx+1] });
                            }
                        }
                        // 存入 macros 字典
                        this.macros[macroName] = {
                            type: 'POLYGON',
                            points: points
                        };
                    }
                }
            }
            if (line.startsWith('ADD')) {
                const m = line.match(/ADD(\d+)([^,]+),?(.+)?/);
                if (m) {
                    const code = parseInt(m[1]);
                    const type = m[2];
                    let paramsStr = m[3] || "";
                    let params = [];
                    if (paramsStr) {
                        params = paramsStr.indexOf('X') !== -1 ? paramsStr.split('X').map(Number) : paramsStr.split(',').map(Number);
                    }
                    this.apertures[code] = { type: type, params: params };
                }
            }
        }


        handleStd(line, configOverride) {
            // ... (前置 G04 处理代码保持不变) ...
            if (line.startsWith('G04')) {
                if (line.includes('Start') || line.includes('End')) {
                    this.commands.push({ type: 5, text: line }); 
                }
                return; 
            }

            // ... (前置 Drill 头部处理代码保持不变) ...
            if (this.state.isDrill) {
                const ignoreFileUnits = configOverride && configOverride.drillUnits && configOverride.drillUnits !== 'auto';
                if (!ignoreFileUnits) {
                    if (line.includes('METRIC')) this.state.units = 'mm';
                    else if (line.includes('INCH')) this.state.units = 'in';
                }
                const toolDef = line.match(/^T(\d+).*?C([\d.]+)/i);
                if (toolDef) {
                    const code = parseInt(toolDef[1]);
                    let diameter = parseFloat(toolDef[2]);
                    if (this.state.units === 'in') diameter *= 25.4;
                    this.apertures[code] = { type: 'C', params: [diameter] };
                }
            }

            // ... (G36/G37 处理保持不变) ...
            if (line.startsWith('G36')) { this.state.isRegion = true; this.state.regionPath = []; return; }
            if (line.startsWith('G37')) { this.state.isRegion = false; if (this.state.regionPath.length > 0) { this.commands.push({ type: 4, path: this.state.regionPath, polarity: this.state.polarity }); } this.state.regionPath = []; return; }

            const prevX = this.state.x;
            const prevY = this.state.y;
            const regex = /([GXYDGTIJ])([\-\+]?\d*\.?\d*)/g;
            let match, tempD = null, hasCoord = false, tempT = null;
            let foundG = false;
            
            // --- [修改 1] 新增槽孔状态变量 ---
            let isSlot = false;
            let slotStart = null; 

            while ((match = regex.exec(line)) !== null) {
                const type = match[1];
                let valStr = match[2];
                let val = parseFloat(valStr);

                if (!valStr.includes('.') && ['X','Y','I','J'].includes(type)) {
                    if (type === 'X' || type === 'I') val = val / this.state.format.divX;
                    else if (type === 'Y' || type === 'J') val = val / this.state.format.divY;
                }
                if (this.state.units === 'in' && ['X','Y','I','J'].includes(type)) val *= 25.4;

                switch(type) {
                    case 'G':
                        if (val === 1) this.state.interpolationMode = 1;
                        else if (val === 2) this.state.interpolationMode = 2; 
                        else if (val === 3) this.state.interpolationMode = 3; 
                        // --- [修改 2] 捕获 G85 槽孔指令 ---
                        else if (val === 85) {
                            isSlot = true;
                            // G85 后面的 X/Y 是终点，当前 state.x/y 是起点，先保存起点
                            slotStart = { x: this.state.x, y: this.state.y };
                        }
                        foundG = true;
                        break;
                    case 'X': this.state.x = val; hasCoord = true; break;
                    case 'Y': this.state.y = val; hasCoord = true; break;
                    case 'I': this.state.i = val; break;
                    case 'J': this.state.j = val; break;
                    case 'D': tempD = parseInt(val); break;
                    case 'T': tempT = parseInt(val); break;
                }
            }

            if (tempT !== null) {
                this.state.apertureCode = tempT;
                if (!this.apertures[tempT]) this.apertures[tempT] = { type: 'C', params: [0.1] };
            }

            // --- [修改 3] 如果检测到槽孔，生成 Type 6 指令并直接返回 ---
            if (isSlot && slotStart) {
                this.updateBounds(this.state.x, this.state.y);
                this.commands.push({
                    type: 6, // Type 6 定义为槽孔 (Slot)
                    x: this.state.x, 
                    y: this.state.y,
                    startX: slotStart.x,
                    startY: slotStart.y,
                    ap: this.state.apertureCode,
                    polarity: this.state.polarity
                });
                return; // 结束，防止被下方逻辑识别为普通钻孔
            }

            if (this.state.isRegion) {
                // 区域填充逻辑 
                if (tempD === 2) { 
                    this.state.regionPath.push({ cmd: 'M', x: this.state.x, y: this.state.y });
                } else if (hasCoord || tempD === 1 || foundG) {
                    this.updateBounds(this.state.x, this.state.y);
                    if (this.state.regionPath.length === 0) {
                         this.state.regionPath.push({ cmd: 'M', x: prevX, y: prevY });
                    }
                    if (this.state.interpolationMode === 1) {
                        this.state.regionPath.push({ cmd: 'L', x: this.state.x, y: this.state.y });
                    } else {
                        this.state.regionPath.push({ 
                            cmd: 'A', x: this.state.x, y: this.state.y, 
                            i: this.state.i || 0, j: this.state.j || 0, mode: this.state.interpolationMode,
                            startX: prevX, startY: prevY
                        });
                    }
                }
                this.state.i = 0; this.state.j = 0;
                return; 
            }

            if (tempD !== null) {
                if (tempD >= 10) this.state.apertureCode = tempD;
                else this.record(tempD, prevX, prevY);
            } else if (hasCoord) {
                if (this.state.isDrill) this.record(3, prevX, prevY);
                else this.record(1, prevX, prevY);
            }
            this.state.i = 0; this.state.j = 0;
        }

        updateBounds(x, y) {
            if (x < this.bounds.minX) this.bounds.minX = x;
            if (x > this.bounds.maxX) this.bounds.maxX = x;
            if (y < this.bounds.minY) this.bounds.minY = y;
            if (y > this.bounds.maxY) this.bounds.maxY = y;
        }

        record(dCode, prevX, prevY) {
            this.updateBounds(this.state.x, this.state.y);
            const cmd = {
                type: dCode, x: this.state.x, y: this.state.y, ap: this.state.apertureCode,
                polarity: this.state.polarity
            };
            if (dCode === 1) {
                cmd.mode = this.state.interpolationMode;
                if (cmd.mode === 2 || cmd.mode === 3) {
                    cmd.i = this.state.i || 0; cmd.j = this.state.j || 0;
                    cmd.prevX = prevX; cmd.prevY = prevY;
                }
            }
            this.commands.push(cmd);
        }
    }

    const parser = new GerberParser();

// ====================================================================================
// 4. 逆向工程工具 (Reverse Engineering Tool)
// ====================================================================================

    const PadTool = {
        // --- 工具：单位转换 (mm -> mil) ---
        toMil: (mm) => {
            if (mm === null || mm === undefined || isNaN(mm)) return null;
            // 1 mm = 39.3700787 mil
            return parseFloat((mm * 39.3700787).toFixed(4));
        },

        // --- 工具：计算圆角比例 (0-100) ---
        calcRadiusRatio: (radius, width, height) => {
            if (!radius || radius <= 0) return 0;
            const minSide = Math.min(Math.abs(width), Math.abs(height));
            if (minSide === 0) return 0;
            const maxRadius = minSide / 2;
            if (Math.abs(radius - maxRadius) < 0.002) return 100;
            let ratio = Math.round(Math.abs(radius / maxRadius) * 100);
            return Math.max(0, Math.min(100, ratio));
        },

        
        // --- 1. 提取阶段 (修改：钻孔图层数据强制转换为 Image 图元) ---
        extractRawData: (files) => {
            const rawPads = []; 
            const rawVias = []; 
            const rawTracks = []; 
            const rawPolys = [];    
            const rawFills = []; 
            const rawImages = []; 
            const rawTextLines = []; 
            const drills = []; 
            const slotOccupiedPoints = []; 

            const getRawContent = (fileName) => {
                const f = rawFilesCache.find(r => r.name === fileName);
                return f ? f.content : "";
            };

            // 1. 宏解析函数
            const parseGerberMacros = (content) => {
                const macros = {};
                if (!content) return macros;
                const regex = /%AM(\w+)\*(.*?)%/g;
                let match;
                while ((match = regex.exec(content)) !== null) {
                    const name = match[1];
                    const body = match[2];
                    const primParts = body.split(',').map(Number);
                    // 仅简单支持 Primitive 4 (Polygon) 
                    // 格式: 4, Exposure, PointCount, x1, y1, ...
                    if (primParts[0] === 4) { 
                        const count = primParts[2];
                        const points = [];
                        for (let i = 0; i < count; i++) {
                            const idx = 3 + (i * 2);
                            if (idx + 1 < primParts.length) {
                                points.push({ x: primParts[idx], y: primParts[idx+1] });
                            }
                        }
                        macros[name] = { type: 'POLYGON', points: points };
                    }
                }
                return macros;
            };

            // 2. 辅助：将光圈(宏或标准形状)转换为路径数据
            const getAperturePath = (ap, cx, cy, toMM, macroDefs) => {
                const pathData = [];
                // A. 优先检查是否为宏定义 (IconRect, IconStar, etc.)
                if (macroDefs[ap.type]) {
                    const macro = macroDefs[ap.type];
                    if (macro.type === 'POLYGON' && macro.points.length > 0) {
                        const start = macro.points[0];
                        pathData.push({ cmd: 'M', x: cx + toMM(start.x), y: cy + toMM(start.y) });
                        for (let i = 1; i < macro.points.length; i++) {
                            const pt = macro.points[i];
                            pathData.push({ cmd: 'L', x: cx + toMM(pt.x), y: cy + toMM(pt.y) });
                        }
                        pathData.push({ cmd: 'L', x: cx + toMM(start.x), y: cy + toMM(start.y) }); // Close
                        return pathData;
                    }
                }

                // B. 标准形状处理 (C, R, RECT)
                const p = ap.params || [];
                const type = ap.type.toUpperCase();
                
                if (type === 'C' || type === 'CIRCLE') {
                    // 圆形模拟 (用两个半圆弧)
                    const r = toMM(p[0]) / 2;
                    pathData.push({ cmd: 'M', x: cx - r, y: cy });
                    pathData.push({ cmd: 'A', x: cx + r, y: cy, i: r, j: 0, mode: 3, startX: cx - r, startY: cy }); // 上半圆
                    pathData.push({ cmd: 'A', x: cx - r, y: cy, i: -r, j: 0, mode: 3, startX: cx + r, startY: cy }); // 下半圆
                } 
                else if (type === 'R' || type === 'RECT' || type === 'RECTANGLE') {
                    // 矩形
                    const w = toMM(p[0]);
                    const h = toMM(p[1] || p[0]); // 如果只有一个参数则为正方形
                    const hw = w / 2;
                    const hh = h / 2;
                    pathData.push({ cmd: 'M', x: cx - hw, y: cy - hh });
                    pathData.push({ cmd: 'L', x: cx + hw, y: cy - hh });
                    pathData.push({ cmd: 'L', x: cx + hw, y: cy + hh });
                    pathData.push({ cmd: 'L', x: cx - hw, y: cy + hh });
                    pathData.push({ cmd: 'L', x: cx - hw, y: cy - hh });
                }
                
                return pathData.length > 0 ? pathData : null;
            };

            // 3. 路径合并算法 (保持不变)
            const mergeSegments = (segments) => {
                if (segments.length === 0) return [];
                const mergedPaths = [];
                const pool = [...segments]; 
                const isEq = (a, b) => Math.abs(a - b) < 0.02; 

                while (pool.length > 0) {
                    const first = pool.shift();
                    const pathDeque = [first];
                    let headX = first.x1, headY = first.y1;
                    let tailX = first.x2, tailY = first.y2;
                    const pathWidth = first.width;

                    let changed = true;
                    while(changed) {
                        changed = false;
                        for (let i = 0; i < pool.length; i++) {
                            const seg = pool[i];
                            if (Math.abs(seg.width - pathWidth) > 0.05) continue;

                            if (isEq(tailX, seg.x1) && isEq(tailY, seg.y1)) {
                                pathDeque.push(seg);
                                tailX = seg.x2; tailY = seg.y2;
                                pool.splice(i, 1); i--; changed = true;
                            }
                            else if (isEq(tailX, seg.x2) && isEq(tailY, seg.y2)) {
                                const rev = { ...seg, x1: seg.x2, y1: seg.y2, x2: seg.x1, y2: seg.y1 };
                                if (rev.type === 'ARC') rev.angle = -rev.angle; 
                                pathDeque.push(rev);
                                tailX = rev.x2; tailY = rev.y2;
                                pool.splice(i, 1); i--; changed = true;
                            }
                            else if (isEq(headX, seg.x2) && isEq(headY, seg.y2)) {
                                pathDeque.unshift(seg);
                                headX = seg.x1; headY = seg.y1;
                                pool.splice(i, 1); i--; changed = true;
                            }
                            else if (isEq(headX, seg.x1) && isEq(headY, seg.y1)) {
                                const rev = { ...seg, x1: seg.x2, y1: seg.y2, x2: seg.x1, y2: seg.y1 };
                                if (rev.type === 'ARC') rev.angle = -rev.angle;
                                pathDeque.unshift(rev);
                                headX = rev.x1; headY = rev.y1;
                                pool.splice(i, 1); i--; changed = true;
                            }
                        }
                    }

                    const currentPath = [];
                    currentPath.push({ cmd: 'M', x: headX, y: headY });
                    pathDeque.forEach(seg => {
                        if (seg.type === 'ARC') {
                            currentPath.push({ cmd: 'A', x: seg.x2, y: seg.y2, sweep: seg.angle });
                        } else {
                            currentPath.push({ cmd: 'L', x: seg.x2, y: seg.y2 });
                        }
                    });
                    mergedPaths.push({ path: currentPath, width: pathWidth });
                }
                return mergedPaths;
            };

            files.forEach(file => {
                const layerId = file.layerId;
                const fileUnit = file.data.units; 
                const toMM = (val) => (val === null || val === undefined) ? 0 : (fileUnit === 'in' ? val * 25.4 : val);
                
                const rawContent = getRawContent(file.name);
                const macroDefs = parseGerberMacros(rawContent);

                // A. 钻孔文件处理
                // [修复] 增加 layerId === 502 (埋盲孔)，确保该图层被作为钻孔数据提取
                if (layerId === 47 || layerId === 500 || layerId === 501 || layerId === 502 || file.name.endsWith('.drl') || file.name.endsWith('.txt')) {
                    if (rawContent) {
                        const fileLines = rawContent.split(/\r?\n/);
                        const tools = {}; let currentTool = null;
                        const regexToolDef = /T(\d+)[^C]*C([\d.]+)/; const regexToolSel = /T(\d+)(?!C)/; 
                        let drillUnitMult = rawContent.includes("INCH") ? 25.4 : 1;
                        const manualToMM = (val) => val * drillUnitMult;
                        for (let line of fileLines) {
                            line = line.trim();
                            const matchDef = line.match(regexToolDef); if (matchDef) { tools[matchDef[1]] = parseFloat(matchDef[2]); continue; }
                            const matchSel = line.match(regexToolSel); if (matchSel) { currentTool = matchSel[1]; continue; }
                            if (line.includes('G85') && currentTool) {
                                const coords = line.match(/X([\d.-]+)Y([\d.-]+).*?X([\d.-]+)Y([\d.-]+)/);
                                if (coords) {
                                    const x1 = manualToMM(parseFloat(coords[1])); const y1 = manualToMM(parseFloat(coords[2]));
                                    const x2 = manualToMM(parseFloat(coords[3])); const y2 = manualToMM(parseFloat(coords[4]));
                                    const dia = manualToMM(tools[currentTool]);
                                    const cx = (x1 + x2) / 2; const cy = (y1 + y2) / 2;
                                    const dx = x2 - x1; const dy = y2 - y1;
                                    const len = Math.sqrt(dx*dx + dy*dy);
                                    let rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                                    while (rotation > 90.1) rotation -= 180; while (rotation < -89.9) rotation += 180;
                                    drills.push({ 
                                        x: cx, y: cy, w: len + dia, h: dia, 
                                        rotation: rotation, dia: dia, 
                                        isPlated: layerId !== 501, 
                                        isSlot: true,
                                        pairStart: file.pairStart, // <--- 新增
                                        pairEnd: file.pairEnd      // <--- 新增
                                    });
                                    slotOccupiedPoints.push({x: cx, y: cy}, {x: x1, y: y1}, {x: x2, y: y2});
                                }
                            }
                        }
                    }
                    file.data.commands.forEach(cmd => {
                        if (cmd.type === 3) { 
                            const cx = toMM(cmd.x); const cy = toMM(cmd.y);
                            if (slotOccupiedPoints.some(p => Math.abs(p.x - cx) < 0.05 && Math.abs(p.y - cy) < 0.05)) return;
                            const ap = file.data.apertures[cmd.ap];
                            if (ap) {
                                let w = 0, h = 0; const p = ap.params;
                                if (ap.type === 'C') { w = toMM(p[0]); h = w; } else if (ap.type === 'O' || ap.type === 'R') { w = toMM(p[0]); h = toMM(p[1]); }
                                // [修改 2] 在 push 时增加 pairStart 和 pairEnd
                                if (w > 0) drills.push({ 
                                    x: cx, y: cy, w: w, h: h, 
                                    rotation: 0, dia: Math.min(w, h), 
                                    isPlated: layerId !== 501, 
                                    isSlot: Math.abs(w - h) > 0.01,
                                    pairStart: file.pairStart, // <--- 新增
                                    pairEnd: file.pairEnd      // <--- 新增
                                });
                            }
                        }
                    });
                    return; 
                }

                // B. 图层文件解析
                let mode = "NONE"; 
                const cmds = file.data.commands;
                let currX = 0, currY = 0;
                let tempPolySegments = []; 
                let currentWidth = 0.254;

                const flushPoly = () => {
                    if (tempPolySegments.length > 0) {
                        const merged = mergeSegments(tempPolySegments);
                        merged.forEach(m => {
                            if (mode === "IMAGE") {
                                rawImages.push({ layerId, width: m.width, path: m.path });
                            } else if (mode === "TEXT") {
                                rawTextLines.push({ layerId, width: m.width, path: m.path });
                            } else {
                                let targetLayer = layerId;
                                // 56 是 DrillDrawing, 导出时通常归类到 Document(13) 或保持 56
                                // 这里保持 56，GeneratePrimitives 中已处理
                                rawPolys.push({ layerId: targetLayer, width: m.width, path: m.path });
                            }
                        });
                        tempPolySegments = [];
                    }
                };

                for (let i = 0; i < cmds.length; i++) {
                    const cmd = cmds[i];
                    
                    // 1. G04 状态切换
                    if (cmd.type === 5) { 
                        if (cmd.text.includes("Pad Start")) { flushPoly(); mode = "PAD"; }
                        else if (cmd.text.includes("Pad End")) { mode = "NONE"; }
                        else if (cmd.text.includes("Via Start")) { flushPoly(); mode = "VIA"; }
                        else if (cmd.text.includes("Via End")) { mode = "NONE"; }
                        else if (cmd.text.includes("Track Start")) { flushPoly(); mode = "TRACK"; }
                        else if (cmd.text.includes("Track End")) { mode = "NONE"; }
                        else if (cmd.text.includes("PolygonModel Start") || cmd.text.includes("Rect Start") || cmd.text.includes("Circle Start")) { 
                            flushPoly(); mode = "POLY"; 
                        }
                        else if (cmd.text.includes("PolygonModel End") || cmd.text.includes("Rect End") || cmd.text.includes("Circle End")) { 
                            flushPoly(); mode = "NONE"; 
                        }
                        else if (cmd.text.includes("Image Start")) { flushPoly(); mode = "IMAGE"; }
                        else if (cmd.text.includes("Image End")) { flushPoly(); mode = "NONE"; }
                        else if (cmd.text.includes("Text Start")) { flushPoly(); mode = "TEXT"; }
                        else if (cmd.text.includes("Text End")) { flushPoly(); mode = "NONE"; }
                        else if (cmd.text.includes("Copper Start")) { flushPoly(); mode = "COPPER"; }
                        else if (cmd.text.includes("Copper End")) { flushPoly(); mode = "NONE"; }
                        // [新增] 钻孔图支持
                        else if (cmd.text.includes("Drill Drawing Start")) { flushPoly(); mode = "DRILL_SYM"; }
                        else if (cmd.text.includes("Drill Drawing End")) { flushPoly(); mode = "NONE"; }
                        continue;
                    }

                    // 2. 区域填充 (G36/G37)
                    if (cmd.type === 4) { 
                        const pathData = cmd.path.map(op => {
                            if (op.cmd === 'M' || op.cmd === 'L') return { cmd: op.cmd, x: toMM(op.x), y: toMM(op.y) };
                            if (op.cmd === 'A') {
                                const sX = toMM(op.startX); const sY = toMM(op.startY);
                                const eX = toMM(op.x); const eY = toMM(op.y);
                                const cX = sX + toMM(op.i); const cY = sY + toMM(op.j);
                                const startAngle = Math.atan2(sY - cY, sX - cX);
                                const endAngle = Math.atan2(eY - cY, eX - cX);
                                let sweep = endAngle - startAngle;
                                if (op.mode === 3) { if (sweep <= 0) sweep += 2 * Math.PI; } 
                                else { if (sweep >= 0) sweep -= 2 * Math.PI; }
                                const sweepDeg = sweep * 180 / Math.PI;
                                return { cmd: 'ARC', x: eX, y: eY, sweep: sweepDeg, cx: cX, cy: cY };
                            }
                        });

                        if (mode === "PAD") {
                            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                            pathData.forEach(pt => {
                                if (pt.x !== undefined && pt.y !== undefined) {
                                    if (pt.x < minX) minX = pt.x; if (pt.x > maxX) maxX = pt.x;
                                    if (pt.y < minY) minY = pt.y; if (pt.y > maxY) maxY = pt.y;
                                }
                            });
                            const cx = (minX + maxX) / 2; const cy = (minY + maxY) / 2;
                            rawPads.push({ layerId, x: cx, y: cy, shape: 'POLYGON', path: pathData, w: 0, h: 0, rotation: 0 });
                            continue;
                        }

                        if (mode === "IMAGE" || mode === "TEXT") {
                            rawImages.push({ layerId, path: pathData, isRegion: true });
                        } else if (mode === "COPPER") {
                            rawFills.push({ layerId, path: pathData });
                        } else {
                            let targetLayer = layerId;
                            if (targetLayer === 56) targetLayer = 56; // 显式保留
                            rawFills.push({ layerId: targetLayer, path: pathData });
                        }
                        continue;
                    }

                    // 3. 线性绘图 (G01/02/03)
                    if (cmd.type === 1 || cmd.type === 2) {
                        const targetX = toMM(cmd.x); const targetY = toMM(cmd.y);
                        
                        if (cmd.type === 1) {
                            const ap = file.data.apertures[cmd.ap];
                            if (ap) currentWidth = toMM(ap.params[0]);
                        }

                        if (mode === "TRACK" || mode === "COPPER") {
                            const isCopperLayer = (layerId === 1 || layerId === 2 || (layerId >= 15 && layerId <= 46));
                            if (isCopperLayer && cmd.type === 1) {
                                if (cmd.mode === 1) { rawTracks.push({ type: "LINE", layerId, x1: currX, y1: currY, x2: targetX, y2: targetY, width: currentWidth }); } 
                                else { 
                                    const centerX = currX + toMM(cmd.i); const centerY = currY + toMM(cmd.j);
                                    const startAngle = Math.atan2(currY - centerY, currX - centerX);
                                    const endAngle = Math.atan2(targetY - centerY, targetX - centerX);
                                    let sweep = endAngle - startAngle;
                                    if (cmd.mode === 3) { if (sweep <= 0) sweep += 2 * Math.PI; } else { if (sweep >= 0) sweep -= 2 * Math.PI; }
                                    rawTracks.push({ type: "ARC", layerId, x1: currX, y1: currY, x2: targetX, y2: targetY, angle: sweep * 180 / Math.PI, width: currentWidth });
                                }
                            }
                        }
                        else if (mode === "POLY" || mode === "IMAGE" || mode === "TEXT" || mode === "DRILL_SYM") { 
                            // 注意：DRILL_SYM 的线段也作为 POLY 处理
                            if (cmd.type !== 2) {
                                let seg = { x1: currX, y1: currY, x2: targetX, y2: targetY, width: currentWidth };
                                if (cmd.mode === 1) { seg.type = 'LINE'; } 
                                else {
                                    seg.type = 'ARC';
                                    const centerX = currX + toMM(cmd.i); const centerY = currY + toMM(cmd.j);
                                    const startAngle = Math.atan2(currY - centerY, currX - centerX);
                                    const endAngle = Math.atan2(targetY - centerY, targetX - centerX);
                                    let sweep = endAngle - startAngle;
                                    if (cmd.mode === 3) { if (sweep <= 0) sweep += 2 * Math.PI; } else { if (sweep >= 0) sweep -= 2 * Math.PI; }
                                    seg.angle = sweep * 180 / Math.PI;
                                }
                                tempPolySegments.push(seg);
                            }
                        }

                        currX = targetX; currY = targetY;
                        continue;
                    }

                    // 4. Flash 指令 (Pad/Via/DrillSymbol)
                    if (cmd.type === 3) { 
                        const ap = file.data.apertures[cmd.ap];
                        if (!ap) continue;
                        
                        currX = toMM(cmd.x); 
                        currY = toMM(cmd.y);

                        // [新增] 处理 Drill Drawing 的图标 Flash
                        if (mode === "DRILL_SYM") {
                            const pathData = getAperturePath(ap, currX, currY, toMM, macroDefs);
                            if (pathData) {
                                // [修改] 钻孔图层不支持 Polygon，改为存入 rawImages 作为图片处理
                                rawImages.push({ layerId: 56, path: pathData });
                            }
                            continue;
                        }

                        if (mode === "PAD") {
                            // 检查宏定义
                            if (macroDefs[ap.type]) {
                                const macro = macroDefs[ap.type];
                                if (macro.type === 'POLYGON') {
                                    // 转换为绝对路径
                                    const pathData = [];
                                    const start = macro.points[0];
                                    pathData.push({ cmd: 'M', x: currX + toMM(start.x), y: currY + toMM(start.y) });
                                    for (let k = 1; k < macro.points.length; k++) {
                                        const pt = macro.points[k];
                                        pathData.push({ cmd: 'L', x: currX + toMM(pt.x), y: currY + toMM(pt.y) });
                                    }
                                    pathData.push({ cmd: 'L', x: currX + toMM(start.x), y: currY + toMM(start.y) });

                                    rawPads.push({ layerId, x: currX, y: currY, shape: 'POLYGON', path: pathData, w: 0, h: 0, rotation: 0 });
                                    continue;
                                }
                            }

                            // 检查重叠
                            const hasPolygonAlready = rawPads.some(existing => 
                                existing.shape === 'POLYGON' &&
                                Math.abs(existing.x - currX) < 0.005 &&
                                Math.abs(existing.y - currY) < 0.005
                            );
                            if (hasPolygonAlready) continue;

                            // 标准处理
                            const p = ap.params || [];
                            const type = (ap.type || 'C').toUpperCase();
                            let w = toMM(p[0]||0.1); let h = w; if (p.length > 1) h = toMM(p[1]);

                            let shape = 'ELLIPSE'; let rotation = 0; let radiusRatio = 0;
                            if (p.length >= 5 && (type.includes('RECT') || type.includes('OVAL') || type.includes('ROUND'))) {
                                const dia = toMM(p[0]); const p1_x = toMM(p[1]); const p1_y = toMM(p[2]); const p2_x = toMM(p[3]); const p2_y = toMM(p[4]);
                                const dx = p2_x - p1_x; const dy = p2_y - p1_y;
                                const len1 = Math.sqrt(dx*dx + dy*dy); const dx2 = (-p1_x) - p2_x; const dy2 = (-p1_y) - p2_y; const len2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                                let dimX = len1 + dia; let dimY = len2 + dia;
                                let rawAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                                w = dimX; h = dimY; rotation = rawAngle;
                                while (rotation > 90.1) { rotation -= 90; [w, h] = [h, w]; } while (rotation < -89.9) { rotation += 90; [w, h] = [h, w]; }
                                rotation = parseFloat(rotation.toFixed(2)); if (Math.abs(rotation) < 0.01) rotation = 0;
                                if (type.includes('OVAL')) shape = 'OVAL'; else { shape = 'RECT'; radiusRatio = PadTool.calcRadiusRatio(dia / 2, w, h); }
                            } else if (type === 'O' || type.includes('OVAL') || type.includes('OBROUND')) {
                                shape = 'OVAL'; w = toMM(p[0]); h = p.length > 1 ? toMM(p[1]) : w; if (p.length >= 3 && p[2]) rotation = parseFloat(p[2]);
                            } else {
                                w = toMM(p[0]||0.1); h = p.length > 1 ? toMM(p[1]) : w; 
                                if (p.length >= 3 && p[2]) rotation = parseFloat(p[2]);
                                if (p.length >= 4 && p[3] > 0) radiusRatio = PadTool.calcRadiusRatio(toMM(p[3]), w, h);
                                if (type === 'C' || type === 'CIRCLE') { shape = 'ELLIPSE'; h = w; } else { shape = 'RECT'; }
                            }
                            if (w > 0 && h > 0) rawPads.push({ layerId, x: toMM(cmd.x), y: toMM(cmd.y), shape, w, h, rotation, radiusRatio });
                        }
                        else if (mode === "VIA") {
                            const p = ap.params || [];
                            let dia = toMM(p[0]||0.1);
                            rawVias.push({ layerId, x: toMM(cmd.x), y: toMM(cmd.y), dia });
                        }
                    }
                }
                flushPoly();
            });

            return { rawPads, rawVias, rawTracks, rawPolys, rawFills, drills, rawImages, rawTextLines }; 
        },

        // --- 2. 聚合阶段 ---
        consolidate: (rawPads, rawVias, rawTracks, rawPolys, rawFills, rawDrills, rawImages, rawTextLines, rawCoppers) => {
            const map = new Map(); 
            const getKey = (x, y) => `${x.toFixed(3)}_${y.toFixed(3)}`;

            // 1. 聚合所有层的焊盘到节点
            rawPads.forEach(p => {
                const key = getKey(p.x, p.y);
                if (!map.has(key)) map.set(key, { x: p.x, y: p.y, top: null, bottom: null, maskTop: null, maskBot: null, pasteTop: null, pasteBot: null, inners: [], drill: null });
                const node = map.get(key);
                if (p.layerId === 1) node.top = p; else if (p.layerId === 2) node.bottom = p; else if (p.layerId === 5) node.maskTop = p; else if (p.layerId === 6) node.maskBot = p; else if (p.layerId === 7) node.pasteTop = p; else if (p.layerId === 8) node.pasteBot = p; else if (p.layerId >= 15 && p.layerId <= 46) node.inners.push(p);
            });
            
            const viaMap = new Map();
            if (rawVias) {
                rawVias.forEach(v => {
                    const key = getKey(v.x, v.y);
                    // [修改 1] 增加 layers 对象用于存储任意层的过孔数据
                    if (!viaMap.has(key)) viaMap.set(key, { top: null, maskTop: null, maskBot: null, layers: {} });
                    const node = viaMap.get(key);
                    
                    // [修改 2] 将该过孔数据存入对应的 layerId 中
                    if (node.layers) node.layers[v.layerId] = v;

                    if (v.layerId === 1) node.top = v; 
                    else if (v.layerId === 5) node.maskTop = v; 
                    else if (v.layerId === 6) node.maskBot = v; 
                });
            }

            // 2. 匹配钻孔 (修复核心：增加模糊匹配)
            const processedDrills = new Set();
            // 先去重 (简单处理)
            const uniqueDrills = [];
            rawDrills.forEach(newD => {
                const existingIdx = uniqueDrills.findIndex(exD => Math.abs(exD.x - newD.x) < 0.02 && Math.abs(exD.y - newD.y) < 0.02);
                if (existingIdx === -1) uniqueDrills.push(newD);
                else { const exD = uniqueDrills[existingIdx]; if (newD.isSlot && !exD.isSlot) uniqueDrills[existingIdx] = newD; }
            });
            
            const drills = uniqueDrills;

            // [辅助] 获取总层数 (上一轮添加的代码，保持不变)
            const copperCountEl = document.getElementById('cfg-copper-layers');
            const totalLayers = copperCountEl ? (parseInt(copperCountEl.value) || 2) : 2;
            const getLyrIdx = (id) => {
                if (id === 1) return 1;
                if (id === 2) return totalLayers;
                if (id >= 15 && id <= 46) return (id - 15) + 2;
                return null;
            };

            drills.forEach((d, idx) => {
                // 1. 埋盲孔跳过逻辑 (保持不变)
                if (d.pairStart && d.pairEnd) {
                    const s = getLyrIdx(d.pairStart);
                    const e = getLyrIdx(d.pairEnd);
                    if (s !== null && e !== null) {
                        const min = Math.min(s, e);
                        const max = Math.max(s, e);
                        if (min !== 1 || max !== totalLayers) return; 
                    }
                }

                // [新增] 合并检查函数
                const tryMergeDrillToPad = (node, drill) => {
                    // 核心修复：
                    // 如果不是槽孔(Slot)，且该位置并没有同时具备 Top 和 Bottom 焊盘
                    // (即：它是一个单面焊盘，比如只有 Bottom)，
                    // 那么强行合并会导致它变成 Layer12 多层焊盘，从而错误地增加顶层铜环。
                    // 这里的策略是：不合并。让 Pad 保持单层，让 Drill 变成独立的 Via。
                    const isSingleSide = (!node.top || !node.bottom);
                    
                    if (!drill.isSlot && isSingleSide) {
                        return; // 跳过合并 -> 结果：单层焊盘 + 独立过孔 (Visual效果正确)
                    }

                    // 执行合并
                    if (!node.drill || drill.isSlot) node.drill = drill;
                    processedDrills.add(drill);
                    drill.isConsumed = true;
                };

                const key = getKey(d.x, d.y);
                
                // 2.1 尝试精确匹配
                if (map.has(key)) { 
                    tryMergeDrillToPad(map.get(key), d);
                } 
                else {
                    // 2.2 模糊匹配
                    let minDist = 0.05; 
                    let matchedKey = null;
                    for (const [k, node] of map) { 
                        const dist = Math.sqrt(Math.pow(node.x - d.x, 2) + Math.pow(node.y - d.y, 2)); 
                        if (dist < minDist) { 
                            minDist = dist; 
                            matchedKey = k; 
                        } 
                    }
                    if (matchedKey) { 
                        tryMergeDrillToPad(map.get(matchedKey), d);
                    }
                }
            });

            // 3. 生成最终对象
            const unifiedPads = [];
            map.forEach(node => {
                const calcExp = (mask, copper) => { if (!mask || !copper) return null; if (mask.w <= 0 || copper.w <= 0) return null; const mMin = Math.min(mask.w, mask.h); const cMin = Math.min(copper.w, copper.h); const exp = (mMin - cMin) / 2; if (exp > 1.0 || exp < -0.05) return null; if (Math.abs(exp) < 0.002) return 0; return exp; };
                let innerRep = null; if (node.inners.length > 0) { innerRep = node.inners.reduce((prev, curr) => (curr.w < prev.w) ? curr : prev); innerRep = { ...innerRep }; }
                // [修改] 增加 inners: node.inners，将所有内层数据透传
                unifiedPads.push({ 
                    x: node.x, y: node.y, 
                    top: node.top, 
                    bottom: node.bottom, 
                    innerRep: innerRep, 
                    inners: node.inners, // <--- 关键修改：保留所有内层焊盘列表
                    drill: node.drill, 
                    exps: { 
                        mt: calcExp(node.maskTop, node.top), 
                        mb: calcExp(node.maskBot, node.bottom), 
                        pt: calcExp(node.pasteTop, node.top), 
                        pb: calcExp(node.pasteBot, node.bottom) 
                    } 
                });
            });
            
            const remainingVias = drills.filter(d => !d.isConsumed).map(d => {
                const key = getKey(d.x, d.y); 
                const viaNode = viaMap.get(key); 
                
                // 默认外径 (如果没有找到对应的Gerber定义)
                let padDia = d.dia; 
                let topExp = null; let botExp = null;
                
                if (viaNode) { 
                    // [修改 3] 优先根据埋盲孔的起始层获取外径
                    if (d.pairStart && viaNode.layers && viaNode.layers[d.pairStart]) {
                        padDia = viaNode.layers[d.pairStart].dia;
                    }
                    // 如果不是埋盲孔或没找到起始层定义，尝试使用顶层定义
                    else if (viaNode.top) {
                        padDia = viaNode.top.dia; 
                    }

                    if (viaNode.maskTop && viaNode.top) { const exp = (viaNode.maskTop.dia - viaNode.top.dia) / 2; if (exp >= -0.05) topExp = exp; } 
                    if (viaNode.maskBot && viaNode.top) { const exp = (viaNode.maskBot.dia - viaNode.top.dia) / 2; if (exp >= -0.05) botExp = exp; } 
                }
                
                return { 
                    x: d.x, y: d.y, w: d.w, h: d.h, 
                    dia: d.dia, padDia: padDia, 
                    topExp: topExp, botExp: botExp, 
                    isPlated: d.isPlated, 
                    isSlot: d.isSlot, 
                    rotation: d.rotation,
                    pairStart: d.pairStart,
                    pairEnd: d.pairEnd
                };
            });

            // [修改] 返回对象增加 coppers
            return { 
                unifiedPads, remainingVias, 
                tracks: rawTracks, polys: rawPolys, fills: rawFills,
                images: rawImages, textLines: rawTextLines, coppers: rawCoppers 
            };
        },

        // --- 3. 生成阶段 (修改：移除特殊的 RECT/CIRCLE 逻辑，统一用 path) ---
        generatePrimitives: (data, versionObj, config) => { 
            const { unifiedPads, remainingVias } = data;
            const isV3 = versionObj.isV3;
            const output = [];
            
            let ticket = versionObj.ticket || 1;
            let idCounter = versionObj.id || 1;
            const nextIds = () => { ticket++; idCounter++; return { t: ticket, id: `e${idCounter}` }; };

            // ... (A. Netlist Data 构建 - 保持不变) ...
            // const netlistMap = new Map(); 
            const netlistPoints = []; 
            const compCounts = {}; 
            let hasNetlist = false;

            if (config && config.tryNetlist && typeof flyingProbeData !== 'undefined' && flyingProbeData) {
                 try {
                    const rows = flyingProbeData.pins.rows;
                    const fields = flyingProbeData.pins.fields;
                    const idxName = fields.indexOf("PIN_NAME");
                    const idxX = fields.indexOf("PIN_X");
                    const idxY = fields.indexOf("PIN_Y");
                    const idxNet = fields.indexOf("NET_NAME");
                    
                    if (idxName >= 0 && idxX >= 0 && idxY >= 0 && idxNet >= 0) {
                        rows.forEach(row => {
                            const rawX = parseFloat(row[idxX]); 
                            const rawY = parseFloat(row[idxY]);
                            const netName = row[idxNet]; 
                            const fullPinName = row[idxName]; 
                            let compName = ""; 
                            let pinNum = fullPinName;
                            const lastUnder = fullPinName.lastIndexOf('_');
                            if (lastUnder > 0) { 
                                compName = fullPinName.substring(0, lastUnder); 
                                pinNum = fullPinName.substring(lastUnder + 1); 
                            } else { 
                                compName = fullPinName; 
                            }
                            if (compName && !compName.toUpperCase().startsWith("PAD")) {
                                if (!compCounts[compName]) compCounts[compName] = 0; 
                                compCounts[compName]++;
                            }
                            netlistPoints.push({ x: rawX, y: rawY, net: netName, num: pinNum, comp: compName });
                        });
                        hasNetlist = true;
                        console.log(`已加载 ${netlistPoints.length} 个网络节点用于匹配`);
                    }
                } catch (e) { console.error("解析飞针网络数据失败:", e); }
            }

            const getCornerObj = (prim) => {
                if (prim && prim.shape === 'RECT' && prim.radiusRatio > 0) return ["ROUND", prim.radiusRatio, prim.radiusRatio];
                return null;
            };

            // [新增] 路径生成函数引用，确保 generatePathStr 在此处可用
            // (通常它定义在 generatePrimitives 内部或作为 PadTool 的方法)
            const generatePathStr = (pathArr) => {
                if (!pathArr || pathArr.length === 0) return [];
                const res = [];
                const startPt = pathArr[0];
                const startX = (startPt.x !== undefined) ? startPt.x : 0;
                const startY = (startPt.y !== undefined) ? startPt.y : 0;
                
                res.push(PadTool.toMil(startX)); 
                res.push(PadTool.toMil(startY)); 

                for (let i = 1; i < pathArr.length; i++) {
                    const pt = pathArr[i];
                    if (pt.cmd === 'L') { 
                        res.push("L"); 
                        res.push(PadTool.toMil(pt.x)); 
                        res.push(PadTool.toMil(pt.y)); 
                    } 
                    else if (pt.cmd === 'A' || pt.cmd === 'ARC') { 
                        res.push("ARC"); 
                        let val = 0;
                        if (pt.sweep !== undefined) val = pt.sweep;
                        else if (pt.angle !== undefined) val = pt.angle;
                        if (typeof val !== 'number') val = 0;

                        res.push(parseFloat(val.toFixed(2))); 
                        res.push(PadTool.toMil(pt.x)); 
                        res.push(PadTool.toMil(pt.y)); 
                    }
                }
                return res;
            };

            // --- 物理层索引计算辅助函数 ---
            const copperCountVal = document.getElementById('cfg-copper-layers') ? parseInt(document.getElementById('cfg-copper-layers').value) : 2;
            
            const getPhysLayerIndex = (layerId) => {
                if (!layerId) return null;
                // 顶层总是 1
                if (layerId === 1) return 1;
                // 底层总是等于总层数
                if (layerId === 2) return copperCountVal;
                // 内层转换: Inner1(15) -> 2, Inner2(16) -> 3 ...
                if (layerId >= 15 && layerId <= 46) {
                    return (layerId - 15) + 2;
                }
                return null;
            };


            // ... (B. Pads 生成 - 修改版) ...
            unifiedPads.forEach(pad => {
                // 1. 公共计算
                const padXMil = PadTool.toMil(pad.x); 
                const padYMil = PadTool.toMil(pad.y);
                let netName = ""; let pinNumber = "1"; let groupId = 0; 

                if (hasNetlist) {
                    const tolerance = 2.5; 
                    const match = netlistPoints.find(p => Math.abs(p.x - padXMil) < tolerance && Math.abs(p.y - padYMil) < tolerance);
                    if (match) { 
                        // netName = match.net || ""; 
                        netName = ""; //当前版本暂不生成网络
                        pinNumber = match.num || "1"; 
                        const cName = match.comp; 
                        if (cName && compCounts[cName] > 1) groupId = cName; 
                    }
                }

                const targets = [];
                
                if (pad.drill) {
                    let holeShape = null; let holeRotation = 0;
                    const holeW = PadTool.toMil(pad.drill.w); 
                    const holeH = PadTool.toMil(pad.drill.h);
                    
                    if (pad.drill.isSlot) { 
                        const maxSide = Math.max(holeW, holeH); 
                        const minSide = Math.min(holeW, holeH); 
                        holeShape = ["SLOT", maxSide, minSide]; 
                        holeRotation = pad.drill.rotation || 0; 
                    } else { 
                        holeShape = ["ROUND", holeW, holeW]; 
                    }
                    const mainPrim = pad.top || pad.bottom || pad.innerRep;
                    if (mainPrim) {
                        targets.push({ layerId: 12, prim: mainPrim, holeShape: holeShape, holeRotation: holeRotation, isPlated: pad.drill.isPlated });
                    }
                } else {
                    // === 无钻孔的情况 (Surface Mount / SMT / Blind Inner) ===
                    
                    // 1. 顶层焊盘 (保持原逻辑，生成 PAD)
                    if (pad.top) {
                        targets.push({ layerId: 1, prim: pad.top, isPlated: true });
                    }
                    
                    // 2. 底层焊盘 (保持原逻辑，生成 PAD)
                    if (pad.bottom) {
                        targets.push({ layerId: 2, prim: pad.bottom, isPlated: true });
                    }
                    
                    // 3. 内层处理 (修改：遍历 pad.inners，为每个存在的内层生成 FILL)
                    if (pad.inners && pad.inners.length > 0) {
                        // 遍历该位置下所有的内层焊盘数据
                        pad.inners.forEach(prim => {
                            const ids = nextIds(); 
                            
                            // 准备几何数据
                            const x = PadTool.toMil(prim.x);
                            const y = PadTool.toMil(prim.y);
                            const w = PadTool.toMil(prim.w);
                            const h = PadTool.toMil(prim.h);
                            const rotation = prim.rotation || 0;
                            
                            let pathContent = [];

                            if (prim.shape === 'POLYGON') {
                                // 异形：直接转换路径
                                pathContent = generatePathStr(prim.path);
                            } else if (prim.shape === 'OVAL') {
                                // === 长圆形 (Obround) 逻辑 ===
                                if (Math.abs(w - h) < 0.01) {
                                    // 宽高接近，视为圆形
                                    pathContent = ["CIRCLE", x, y, w / 2];
                                } else {
                                    // 计算旋转参数
                                    const rad = -rotation * Math.PI / 180;
                                    const cos = Math.cos(rad);
                                    const sin = Math.sin(rad);
                                    const rotate = (px, py) => ({
                                        x: parseFloat((x + px * cos - py * sin).toFixed(4)),
                                        y: parseFloat((y + px * sin + py * cos).toFixed(4))
                                    });

                                    const r = Math.min(w, h) / 2;
                                    const dist = (Math.max(w, h) / 2) - r; 
                                    const isHorizontal = w > h;

                                    let p1, p2, p3, p4;
                                    
                                    if (isHorizontal) {
                                        p1 = {x: -dist, y: r};
                                        p2 = {x: dist, y: r};
                                        p3 = {x: dist, y: -r};
                                        p4 = {x: -dist, y: -r};
                                    } else {
                                        p1 = {x: -r, y: dist};
                                        p2 = {x: r, y: dist};
                                        p3 = {x: r, y: -dist};
                                        p4 = {x: -r, y: -dist};
                                    }

                                    const P1 = rotate(p1.x, p1.y);
                                    const P2 = rotate(p2.x, p2.y);
                                    const P3 = rotate(p3.x, p3.y);
                                    const P4 = rotate(p4.x, p4.y);

                                    if (isHorizontal) {
                                        pathContent = [
                                            P1.x, P1.y, "L",
                                            P2.x, P2.y, "ARC", -180, // 右侧半圆
                                            P3.x, P3.y, "L",
                                            P4.x, P4.y, "ARC", -180, // 左侧半圆
                                            P1.x, P1.y
                                        ];
                                    } else {
                                        pathContent = [
                                            P1.x, P1.y, "ARC", -180, // 顶部半圆
                                            P2.x, P2.y, "L",
                                            P3.x, P3.y, "ARC", -180, // 底部半圆
                                            P4.x, P4.y, "L",
                                            P1.x, P1.y
                                        ];
                                    }
                                }
                            } else if (prim.shape === 'RECT' || prim.shape === 'ROUNDRECT') {
                                // === 矩形/圆角矩形逻辑 (修正版：修复旋转方向) ===
                                const dx = w / 2;
                                const dy = h / 2;
                                
                                // [关键修改]：移除负号。
                                // EDA 坐标系通常 Y 轴向上，正角度为逆时针旋转。
                                // 原代码的 -rotation 导致了顺时针旋转，视觉上产生水平翻转的效果。
                                const rad = rotation * Math.PI / 180; 
                                
                                const cos = Math.cos(rad);
                                const sin = Math.sin(rad);
                                
                                // 旋转变换函数 (标准笛卡尔坐标系旋转)
                                // x' = x*cos - y*sin
                                // y' = x*sin + y*cos
                                const rotate = (px, py) => ({
                                    x: parseFloat((x + px * cos - py * sin).toFixed(4)),
                                    y: parseFloat((y + px * sin + py * cos).toFixed(4))
                                });

                                // 计算圆角半径
                                let r = 0;
                                if (prim.radiusRatio && prim.radiusRatio > 0) {
                                    r = Math.min(w, h) / 2 * (prim.radiusRatio / 100);
                                }

                                if (r > 0.001) {
                                    // --- 生成圆角填充路径 (Line + Arc) ---
                                    // 逆时针顺序绘制：上边 -> 左边 -> 下边 -> 右边 (或反之)
                                    // 这里保持顺时针点序绘制，配合 -90 的 Arc Sweep (顺时针弧)
                                    // 点的定义基于未旋转的矩形，然后应用 rotate 函数变换到世界坐标
                                    
                                    const pt_top_l = rotate(-dx + r, dy); // 顶左
                                    const pt_top_r = rotate(dx - r, dy);  // 顶右
                                    
                                    const pt_right_t = rotate(dx, dy - r); // 右上
                                    const pt_right_b = rotate(dx, -dy + r);// 右下
                                    
                                    const pt_bottom_r = rotate(dx - r, -dy); // 底右
                                    const pt_bottom_l = rotate(-dx + r, -dy);// 底左
                                    
                                    const pt_left_b = rotate(-dx, -dy + r); // 左下
                                    const pt_left_t = rotate(-dx, dy - r);  // 左上

                                    pathContent = [
                                        pt_top_l.x, pt_top_l.y, "L",
                                        pt_top_r.x, pt_top_r.y, "ARC", -90, pt_right_t.x, pt_right_t.y,
                                        "L",
                                        pt_right_b.x, pt_right_b.y, "ARC", -90, pt_bottom_r.x, pt_bottom_r.y,
                                        "L",
                                        pt_bottom_l.x, pt_bottom_l.y, "ARC", -90, pt_left_b.x, pt_left_b.y,
                                        "L",
                                        pt_left_t.x, pt_left_t.y, "ARC", -90, pt_top_l.x, pt_top_l.y
                                    ];

                                } else {
                                    // --- 直角矩形逻辑 ---
                                    const p1 = rotate(-dx, -dy);
                                    const p2 = rotate(dx, -dy);
                                    const p3 = rotate(dx, dy);
                                    const p4 = rotate(-dx, dy);

                                    pathContent = [
                                        p1.x, p1.y, "L",
                                        p2.x, p2.y, "L",
                                        p3.x, p3.y, "L",
                                        p4.x, p4.y, "L",
                                        p1.x, p1.y
                                    ];
                                }
                            } else {
                                // 圆形
                                const r = Math.min(w, h) / 2;
                                pathContent = ["CIRCLE", x, y, r];
                            }

                            // 生成图元 JSON
                            // 注意：这里的 layerId 使用的是当前遍历到的 prim.layerId
                            // 这样就能分别生成 Inner1, Inner2, Inner3 等层的填充
                            if (isV3) {
                                const obj = { "type": "FILL", "ticket": ids.t, "id": ids.id };
                                const content = {
                                    "partitionId": "", "groupId": groupId, "netName": netName, 
                                    "layerId": prim.layerId, 
                                    "width": 0, 
                                    "fillStyle": "SOLID", 
                                    "path": [pathContent], 
                                    "locked": false, "zIndex": -1, "isBridgingCopper": false, "networkList": [], "refs": null
                                };
                                output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                            } else {
                                const arr = ["FILL", ids.id, groupId, netName, prim.layerId, 0, 0, [pathContent], 0];
                                output.push(JSON.stringify(arr));
                            }
                        });
                    }
                }

                targets.forEach(tgt => {
                    const ids = nextIds();
                    const layerId = tgt.layerId;
                    const mainPrim = tgt.prim;

                    let rotation = mainPrim.rotation || 0;
                    if (tgt.holeShape && tgt.holeShape[0] === "SLOT" && Math.abs(rotation) < 0.1 && Math.abs(tgt.holeRotation) > 0.1) {
                        rotation = tgt.holeRotation;
                    }
                    
                    let primW = PadTool.toMil(mainPrim.w); 
                    let primH = PadTool.toMil(mainPrim.h);
                    const originalRot = mainPrim.rotation || 0;
                    
                    const rotDiff = Math.abs(rotation - originalRot) % 180;
                    if (Math.abs(rotDiff - 90) < 1.0) { const temp = primW; primW = primH; primH = temp; }

                    const makeShapeArr = (s, w, h, rr) => {
                        let shapeName = s;
                        if (shapeName === 'ROUND') shapeName = 'ELLIPSE';
                        if (shapeName === 'ELLIPSE' || shapeName === 'OVAL') return [shapeName, w, h];
                        
                        // [修改处] 强制保留第4位参数，即使是 0
                        if (shapeName === 'RECT') return ["RECT", w, h, rr || 0];
                        
                        return [shapeName, w, h];
                    };
                    
                    // --- [新增/修改] 对异形焊盘的处理 ---
                    let defaultShape;
                    if (mainPrim.shape === 'POLYGON') {
                        // 异形焊盘：["POLYGON", [path...]]
                        const pathArr = generatePathStr(mainPrim.path);
                        defaultShape = ["POLYGON", pathArr];
                    } else {
                        // 普通焊盘
                        defaultShape = makeShapeArr(mainPrim.shape, primW, primH, mainPrim.radiusRatio || 0);
                    }
                    // ------------------------------------

                    let cornerObj = getCornerObj(mainPrim);
                    
                    let specialPads = []; 
                    if (layerId === 12) {
                        const t = pad.top; const b = pad.bottom; const i = pad.innerRep;
                        const isEq = (o1, o2) => {
                            if (!o1 && !o2) return true;
                            if (!o1 || !o2) return false;
                            // 异形焊盘暂时不支持作为 specialPads 的比较逻辑，因为 path 太复杂
                            if (o1.shape === 'POLYGON' || o2.shape === 'POLYGON') return false;

                            return Math.abs(o1.w - o2.w) < 0.005 && Math.abs(o1.h - o2.h) < 0.005 && Math.abs((o1.rotation||0) - (o2.rotation||0)) < 0.1 && (o1.radiusRatio||0) === (o2.radiusRatio||0) && o1.shape === o2.shape;
                        };
                        
                        if (!(isEq(t, b) && (i ? isEq(t, i) : true))) {
                            const processInner = (p) => {
                                // 简单处理：如果是 Polygon，这里暂不支持转为内层特殊焊盘形状，回退到 Rect
                                if (p.shape === 'POLYGON') return ["RECT", 10, 10]; 

                                let pw = PadTool.toMil(p.w); let ph = PadTool.toMil(p.h);
                                const innerRot = p.rotation || 0; const innerDiff = Math.abs(rotation - innerRot) % 180;
                                if (Math.abs(innerDiff - 90) < 1.0) [pw, ph] = [ph, pw];
                                return makeShapeArr(p.shape, pw, ph, p.radiusRatio);
                            };
                            if (t) specialPads.push([1, 1, processInner(t)]);
                            if (i) specialPads.push([1, 2, processInner(i)]); 
                            if (b) specialPads.push([2, 2, processInner(b)]);
                        }
                    }

                    let mt = null, mb = null, pt = null, pb = null;
                    if (layerId === 12) {
                         mt = PadTool.toMil(pad.exps.mt); mb = PadTool.toMil(pad.exps.mb);
                         pt = PadTool.toMil(pad.exps.pt); pb = PadTool.toMil(pad.exps.pb);
                    } else if (layerId === 1) { 
                         mt = PadTool.toMil(pad.exps.mt); 
                         pt = PadTool.toMil(pad.exps.pt);
                    } else if (layerId === 2) { 
                         mb = PadTool.toMil(pad.exps.mb); 
                         pb = PadTool.toMil(pad.exps.pb);
                    }

                    let relRotation = 0;
                    if (tgt.holeShape && tgt.holeShape[0] === 'SLOT') { 
                        if (Math.abs(rotation - tgt.holeRotation) > 0.1) relRotation = tgt.holeRotation - rotation; 
                    }

                    if (isV3) {
                        const obj = { "type": "PAD", "ticket": ids.t, "id": ids.id };
                        // [修复代码]：增加 radius 字段，支持圆角矩形
                        const padInfoObj = (defaultShape[0] === 'POLYGON') 
                            ? { "padType": "POLYGON", "path": defaultShape[1] } 
                            : { 
                                "padType": defaultShape[0], 
                                "width": defaultShape[1], 
                                "height": defaultShape[2], 
                                "radius": defaultShape[3] || 0  // <--- 核心修复：取出数组第4位的圆角参数
                            };
                        const content = { 
                            "partitionId": "", "groupId": groupId, "netName": netName, "layerId": layerId, "num": pinNumber, 
                            "centerX": padXMil, "centerY": padYMil, "padAngle": rotation, 
                            "hole": tgt.holeShape ? { "holeType": tgt.holeShape[0], "width": tgt.holeShape[1], "height": tgt.holeShape[2] } : null, 
                            "defaultPad": padInfoObj, 
                            "specialPad": specialPads.map(sp => ({ "startLayer": sp[0], "endLayer": sp[1], "pad": { "padType": sp[2][0], "width": sp[2][1], "height": sp[2][2], "radius": sp[2][3]||0 } })), 
                            "padOffsetX": 0, "padOffsetY": 0, "relativeAngle": relRotation, 
                            "plated": tgt.isPlated !== undefined ? tgt.isPlated : true, 
                            "padType": "NORMAL", 
                            "topSolderExpansion": mt, "bottomSolderExpansion": mb, "topPasteExpansion": pt, "bottomPasteExpansion": pb, 
                            "locked": false, "zIndex": null, "connectMode": null, "spokeSpace": null, "spokeWidth": null, "spokeAngle": null, "unusedInnerLayers": [], "padLen": 0, "attrsMap": {} 
                        };
                        output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                    } else {
                        const arr = [ 
                            "PAD", ids.id, groupId, netName, layerId, pinNumber, 
                            padXMil, padYMil, rotation, 
                            tgt.holeShape, 
                            defaultShape, 
                            specialPads, 
                            0, 0, relRotation, 
                            tgt.isPlated ? 1 : 0, 
                            0, 
                            mt, mb, pt, pb, 
                            0, cornerObj, null, null, null, null, [] 
                        ];
                        output.push(JSON.stringify(arr));
                    }
                });
            });

            // ... (C. Vias 生成 - 保持不变) ...
             remainingVias.forEach(v => {
                const ids = nextIds();
                const diaMil = PadTool.toMil(v.w);
                // --- [新增 2] 计算过孔的层范围字符串 ---
                let layerRangeStr = ""; 
                if (v.pairStart && v.pairEnd) {
                    const startIdx = getPhysLayerIndex(v.pairStart);
                    const endIdx = getPhysLayerIndex(v.pairEnd);
                    
                    // 只有当两个都是有效的物理层，且不构通孔(1-Max)时才写入
                    // 当然，如果用户显式选了 Top-Bottom，写 "1-N" 也是合法的，或者是空字符串表示通孔
                    // 这里为了严谨，只要有定义且有效，就生成字符串
                    if (startIdx !== null && endIdx !== null) {
                        // 确保小的在前，大的在后 (例如 "1-2")
                        const s = Math.min(startIdx, endIdx);
                        const e = Math.max(startIdx, endIdx);
                        
                        // 如果是全通孔 (Top -> Bottom)，标准格式通常为空字符串，也可以是 "1-N"
                        // 为了兼容性，如果是全层，保持空字符串；如果是埋盲孔，则输出
                        if (s === 1 && e === copperCountVal) {
                            layerRangeStr = ""; 
                        } else {
                            layerRangeStr = `${s}-${e}`;
                        }
                    }
                }
                // ------------------------------------
                
                // 遍历处理剩余的独立钻孔数据 v
                if (!v.isPlated) {
                    // === 分支 1：非金属化孔 (NPTH) ===
                    // 计算半径和 mil 单位的坐标
                    const radius = diaMil / 2;
                    const x = PadTool.toMil(v.x);
                    const y = PadTool.toMil(v.y);

                    if (isV3) {
                        // --- [修改] V3 格式处理：使用 FILL (实心填充) 替代 VIA ---
                        const obj = { "type": "FILL", "ticket": ids.t, "id": ids.id };
                        const content = { 
                            "partitionId": "", 
                            "groupId": 0, 
                            "netName": "", 
                            "layerId": 12,      // 12 = Multi-Layer
                            "width": 1,         // 线宽，保留示例中的 1
                            "fillStyle": "SOLID", // 填充模式：实心
                            "path": [["CIRCLE", x, y, radius]], // 路径定义：[类型, x, y, 半径]
                            "locked": false, 
                            "zIndex": null, 
                            "isBridgingCopper": false, 
                            "networkList": [], 
                            "refs": null 
                        };
                        output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                    } else {
                        // --- V2 格式处理 ---
                        // V2 中通常使用 "FILL" (填充区域) 或 "HOLE" (挖孔) 来表示非金属化孔
                        // 此处生成一个圆形挖孔区域 (CIRCLE)，layerId 12 (Multi-Layer)
                        // 格式: ["FILL", id, group, net, layerId, type(1=solid), 0, path, rot]
                        const arr = ["FILL", ids.id, 0, "", 12, 1, 0, [["CIRCLE", x, y, radius]], 0];
                        output.push(JSON.stringify(arr));
                    }
                } else {
                    // === 分支 2：金属化孔 (PTH) ===
                    
                    if (v.isSlot) {
                        // --- 情况 2.1：槽孔 (Slot) ---
                        // 转换槽孔尺寸到 mil
                        const w = PadTool.toMil(v.w);
                        const h = PadTool.toMil(v.h);
                        // 确定长边和短边
                        const maxS = Math.max(w, h);
                        const minS = Math.min(w, h);

                        // 生成 V2 格式的 PAD (V2 对槽孔通常作为 PAD 处理)
                        // 格式: ["PAD", id, group, net, layerId, pinNum, x, y, rot, holeShape, padShape, ...]
                        // holeShape: ["SLOT", 长, 宽]
                        // padShape: ["OVAL", 长+5mil, 宽+5mil] (默认加一点铜环宽度)
                        const arr = [
                            "PAD", ids.id, 0, "", 12, "1",
                            PadTool.toMil(v.x), PadTool.toMil(v.y),
                            v.rotation || 0,
                            ["SLOT", maxS, minS],
                            ["OVAL", maxS + 5, minS + 5], // 自动生成椭圆焊盘形状
                            [], 0, 0, 0, 1, 0, null, null, null, null, 0, null, null, null, null, []
                        ];
                        output.push(JSON.stringify(arr));
                    } else {
                        // --- 情况 2.2：圆形钻孔 (Standard Via) ---
                        const padMil = PadTool.toMil(v.padDia); // 过孔外径
                        const mt = PadTool.toMil(v.topExp);     // 顶层阻焊扩展
                        const mb = PadTool.toMil(v.botExp);     // 底层阻焊扩展

                        if (isV3) {
                            // --- V3 格式处理 ---
                            const obj = { "type": "VIA", "ticket": ids.t, "id": ids.id };
                            
                            const content = {
                                "partitionId": "",
                                "groupId": 0,
                                "netName": "",
                                "ruleName": layerRangeStr,
                                "centerX": PadTool.toMil(v.x),
                                "centerY": PadTool.toMil(v.y),
                                
                                // [修改] 使用 Diameter (直径) 替代 Radius (半径)
                                "holeDiameter": diaMil,   // 钻孔直径
                                "viaDiameter": padMil,    // 过孔直径
                                
                                // [修改] 类型设为 NORMAL (参考你提供的正常源码)
                                "viaType": "NORMAL",      
                                
                                "topSolderExpansion": mt,
                                "bottomSolderExpansion": mb,
                                "locked": false,
                                "unusedInnerLayers": []   // 补充空数组，保持格式一致
                            };
                            output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                        } else {
                            // --- V2 格式处理 ---
                            // --- [修改 3] V2 格式导出逻辑 ---
                            // 格式: ["VIA", id, group, net, layerRangeStr, x, y, drillDia, padDia, rot, topExp, botExp, 0]
                            // layerRangeStr: 用于表示盲埋孔层对 (如 "1-2")，若是通孔则为空字符串 ""
                            const arr = [
                                "VIA", ids.id, 0, "",
                                layerRangeStr,         // 之前计算好的层对字符串
                                PadTool.toMil(v.x),
                                PadTool.toMil(v.y),
                                diaMil,                // 钻孔直径
                                padMil,                // 过孔直径
                                0,                     // 旋转角度
                                mt,                    // 顶层阻焊扩展
                                mb,                    // 底层阻焊扩展
                                0
                            ];
                            output.push(JSON.stringify(arr));
                        }
                    }
                }
            });

            // ... (D. Text 生成 - 保持不变) ...
            if (config && config.tryNetlist && typeof flyingProbeData !== 'undefined' && flyingProbeData) {
                try {
                    const rows = flyingProbeData.components.rows;
                    const fields = flyingProbeData.components.fields;
                    const idxName = fields.indexOf("COMPONENT_NAME"); 
                    const idxLayer = fields.indexOf("LAYER"); 
                    const idxX = fields.indexOf("X_COORDINATE"); 
                    const idxY = fields.indexOf("Y_COORDINATE"); 
                    const idxAngle = fields.indexOf("ANGLE");

                    if (idxName >= 0 && idxX >= 0) {
                        let textCount = 0;
                        rows.forEach(row => {
                            const name = row[idxName];
                            if (!name || name.toUpperCase().startsWith("PAD")) {
                                return; 
                            }
                            const layerStr = row[idxLayer]; 
                            const x = parseFloat(row[idxX]); 
                            const y = parseFloat(row[idxY]); 
                            const angle = parseFloat(row[idxAngle] || 0);

                            let layerId = 9; // Top Assembly
                            let isMirror = 0; 
                            if (layerStr === "B") { 
                                layerId = 10; // Bottom Assembly
                                isMirror = 1; 
                            }

                            let groupId = 0; 
                            if (compCounts[name] && compCounts[name] > 1) { 
                                groupId = name; 
                            }

                            const ids = nextIds();
                            
                            if (isV3) {
                                // --- [修改] V3 格式处理：使用 STRING (字符串) ---
                                const obj = { "type": "STRING", "ticket": ids.t, "id": ids.id };
                                
                                const content = { 
                                    "partitionId": "", 
                                    "groupId": groupId, 
                                    "layerId": layerId, 
                                    "x": x,                       // 位置 X
                                    "y": y,                       // 位置 Y
                                    "text": name,                 // 内容 (元件位号)
                                    "fontFamily": "default2",     // 字体名称
                                    "fontSize": 20,               // 字号 (mil)
                                    "strokeWidth": 4,             // 粗细 (mil)
                                    "bold": false,                // 是否加粗 (示例为0, 定义为boolean, 使用false)
                                    "italic": false,              // 是否斜体
                                    // [注意] 对齐模式：原 V2 代码使用的 5 代表 CENTER-CENTER。
                                    // 即使示例给了 LEFT_BOTTOM，为了保证导入位置不偏移，这里建议使用 "CENTER"。
                                    // 如果你确定坐标是左下角坐标，可以改为 "LEFT_BOTTOM"。
                                    "origin": "CENTER_MIDDLE",           
                                    "angle": angle,               // 旋转角度
                                    "reverse": false,             // 是否反相扩展
                                    "expansion": 0,               // 反相扩展尺寸
                                    "mirror": !!isMirror,         // 是否镜像
                                    "locked": false,              // 是否锁定
                                    "zIndex": null,               // Z 轴高度
                                    "specialColor": null          // 特殊颜色
                                };
                                output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                            } else {
                                const arr = ["STRING", ids.id, groupId, layerId, x, y, name, "default2", 20, 4, 0, 0, 5, angle, 0, 0, isMirror, 0];
                                output.push(JSON.stringify(arr));
                            }
                            textCount++;
                        });
                        console.log(`生成了 ${textCount} 个位号标记`);
                    }
                } catch (e) { console.error("生成位号标记失败:", e); }
            }

            // ... (E. Tracks 生成 - 保持不变) ...
            if (data.tracks) {
                data.tracks.forEach(t => {
                    const ids = nextIds();
                    const x1 = PadTool.toMil(t.x1); const y1 = PadTool.toMil(t.y1);
                    const x2 = PadTool.toMil(t.x2); const y2 = PadTool.toMil(t.y2);
                    const width = PadTool.toMil(t.width);
                    if (isV3) {
                        // --- [修改] V3 格式处理 ---
                        
                        // 1. 确定图元类型
                        // 原逻辑将 LINE 转为 TRACK，根据新定义，LINE 对应的 type 就是 "LINE"
                        const objType = t.type; 
                        const obj = { "type": objType, "ticket": ids.t, "id": ids.id };

                        // 2. 构建通用 Content (LINE 和 ARC 共有的字段)
                        const content = { 
                            "partitionId": "", 
                            "groupId": 0, 
                            "netName": "", 
                            "layerId": t.layerId, 
                            "locked": false, 
                            "zIndex": null, 
                            "width": width,        // [修改] 线宽属性名为 width (原为 strokeWidth)
                            "startX": x1,          // [修改] 起始 X
                            "startY": y1,          // [修改] 起始 Y
                            "endX": x2,            // [修改] 结束 X
                            "endY": y2             // [修改] 结束 Y
                        };

                        // 3. 针对 ARC (圆弧) 的特殊处理
                        if (objType === 'ARC') {
                            content.angle = t.angle; // 圆弧角
                            content.arcType = "DOT"; // [新增] 圆弧类型：DOT (两点圆弧)
                        }

                        output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                    } else {
                        // --- V2 格式处理 (保持不变) ---
                        if (t.type === 'LINE') { 
                            const arr = ["LINE", ids.id, 0, "", t.layerId, x1, y1, x2, y2, width, 0]; 
                            output.push(JSON.stringify(arr)); 
                        } else { 
                            const angle = parseFloat(t.angle.toFixed(4)); 
                            const arr = ["ARC", ids.id, 0, "", t.layerId, x1, y1, x2, y2, angle, width, 0]; 
                            output.push(JSON.stringify(arr)); 
                        }
                    }
                });
                console.log(`生成了 ${data.tracks.length} 条导线`);
            }

            // ... (F. Polys 生成 - 保持不变) ...
            if (data.polys) {
                data.polys.forEach(p => {
                    const ids = nextIds();
                    const width = PadTool.toMil(p.width);
                    const pathObj = generatePathStr(p.path);

                    if (isV3) {
                    // --- [修改] V3 格式处理：使用 POLY (折线) 替代 REGION ---
                    const obj = { "type": "POLY", "ticket": ids.t, "id": ids.id };
                    
                    const content = {
                        "partitionId": "",
                        "groupId": 0,
                        "netName": "",
                        "layerId": p.layerId,
                        "locked": false,
                        "zIndex": null,
                        "width": width,          // [修改] 线宽属性名为 width (原为 strokeWidth)
                        "path": pathObj,         // 路径数组 [x, y, "L", x, y...]
                        "polyType": "NORMAL"     // [新增] 折线类型：NORMAL (普通)
                    };
                    
                    output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                } else {
                    // --- V2 格式处理 (保持不变) ---
                    // ["POLY", id, group, net, layer, width, path, type]
                    const arr = ["POLY", ids.id, 0, "", p.layerId, width, pathObj, 0];
                    output.push(JSON.stringify(arr));
                }
                });
                console.log(`生成了 ${data.polys.length} 个折线`);
            }

            // ... (G. Fills 生成 - 保持不变) ...
            if (data.fills) {
                data.fills.forEach(f => {
                    const ids = nextIds();
                    const singlePath = generatePathStr(f.path);
                    if (isV3) {
                        // --- [修改] V3 格式处理 ---
                        const obj = { "type": "FILL", "ticket": ids.t, "id": ids.id };
                        
                        const content = {
                            "partitionId": "",
                            "groupId": 0,
                            "netName": "",
                            "layerId": f.layerId,
                            "width": 0.2,           // 线宽 (保持与 V2 逻辑一致，或者设为 0)
                            "fillStyle": "SOLID",   // [新增] 填充模式：SOLID (实心填充)
                            "path": [singlePath],   // [注意] 路径需要包裹在数组中 [[x, y, ...]]
                            "locked": false,
                            "zIndex": null,
                            "isBridgingCopper": false, // 是否是桥接铜
                            "networkList": [],
                            "refs": null            // 关联图元
                        };
                        
                        output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                    } else {
                        // --- V2 格式处理 (保持不变) ---
                        // ["FILL", id, group, net, layer, type(0.2?? width?), type(0=solid), path, rot]
                        const arr = ["FILL", ids.id, 0, "", f.layerId, 0.2, 0, [singlePath], 0];
                        output.push(JSON.stringify(arr));
                    }
                });
                console.log(`生成了 ${data.fills.length} 个填充区域`);
            }

            // ... (H. Image 生成 - 保持不变) ...
            if (data.images) {
                data.images.forEach(img => {
                    const ids = nextIds();
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    
                    const processPt = (xMM, yMM) => {
                        const x = PadTool.toMil(xMM);
                        const y = PadTool.toMil(yMM);
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                        return { x, y };
                    };
                    const rawPath = img.path;
                    if (!rawPath || rawPath.length === 0) return;
                    const pathArr = [];
                    if (rawPath[0].cmd === 'M') {
                        const p = processPt(rawPath[0].x, rawPath[0].y);
                        pathArr.push(p.x, p.y); 
                    } else {
                        const p = processPt(rawPath[0].x, rawPath[0].y);
                        pathArr.push(p.x, p.y);
                    }
                    for (let i = 1; i < rawPath.length; i++) {
                        const op = rawPath[i];
                        if (op.cmd === 'L') {
                            const p = processPt(op.x, op.y);
                            pathArr.push("L", p.x, p.y);
                        } else if (op.cmd === 'A') {
                            const p = processPt(op.x, op.y);
                            pathArr.push("L", p.x, p.y); 
                        }
                    }
                    // --- [修改开始] 计算宽高并进行非零校验 ---
                    const width = maxX - minX;
                    const height = maxY - minY;

                    // 如果尺寸无效 (<= 0.001 mil)，则剔除
                    if (width <= 0.001 || height <= 0.001) return; 
                    // --- [修改结束] ---
                    // const width = maxX - minX;
                    // const height = maxY - minY;
                    const tlX = minX;
                    const tlY = maxY;
                    let imgRot = 0;
                    let imgMirror = 0;
                    // (前置逻辑：判断是否为底层，设置旋转和镜像)
                    if ([2, 4, 6, 8, 10].includes(img.layerId)) {
                        imgRot = 360;  
                        imgMirror = 1; 
                    }

                    if (isV3) {
                        // --- [修改] V3 格式处理：IMAGE 图元 ---
                        const obj = { "type": "IMAGE", "ticket": ids.t, "id": ids.id };
                        
                        const content = {
                            "partitionId": "",
                            "groupId": 0,
                            "layerId": img.layerId,
                            
                            // 坐标与尺寸
                            "startX": tlX,          // 左上 X
                            "startY": tlY,          // 左上 Y
                            "width": width,         // 宽
                            "height": height,       // 高
                            
                            // 变换属性
                            "angle": imgRot,        // 旋转角度 (通常底层为 360)
                            "mirror": !!imgMirror,  // 镜像 (将 0/1 转为 false/true)
                            
                            // 路径数据：需注意 V3 图片路径是二维数组 [[path...]]
                            "path": [pathArr],      
                            
                            // 通用属性
                            "locked": false,
                            "zIndex": -1,
                            "specialColor": null
                        };

                        output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                    } else {
                        // --- V2 格式处理 (保持不变) ---
                        // ["IMAGE", id, group, layer, x, y, w, h, rot, mirror, [path], locked]
                        const arr = ["IMAGE", ids.id, 0, img.layerId, tlX, tlY, width, height, imgRot, imgMirror, [pathArr], 0];
                        output.push(JSON.stringify(arr));
                    }
                });
                console.log(`生成了 ${data.images.length} 个图片图元`);
            }

            // ... (I. Text Lines 生成 - 保持不变) ...
            if (data.textLines) {
                data.textLines.forEach(t => {
                    const ids = nextIds();
                    const width = PadTool.toMil(t.width);
                    const pathObj = generatePathStr(t.path);
                    if (isV3) {
                    // --- [修改] V3 格式处理：文字折线使用 POLY 图元 ---
                    const obj = { "type": "POLY", "ticket": ids.t, "id": ids.id };
                    
                    const content = { 
                        "partitionId": "", 
                        "groupId": 0, 
                        "netName": "", 
                        "layerId": t.layerId, 
                        "locked": false, 
                        "zIndex": null, 
                        "width": width,          // [修改] 线宽属性名为 width (原为 strokeWidth)
                        "path": pathObj,         // 路径数组
                        "polyType": "NORMAL"     // [新增] 折线类型：普通
                    };
                    
                    output.push(JSON.stringify(obj) + "||" + JSON.stringify(content));
                } else {
                    // --- V2 格式处理 (保持不变) ---
                    // ["POLY", id, group, net, layer, width, path, type]
                    const arr = ["POLY", ids.id, 0, "", t.layerId, width, pathObj, 0];
                    output.push(JSON.stringify(arr));
                }
                });
                console.log(`生成了 ${data.textLines.length} 条文字折线`);
            }

            return output;
        }
    };

// ====================================================================================
// 5. 辅助工具函数 (Utils)
// ====================================================================================

    // --- [新增] 辅助：将文件名中的层名 (Top, Bottom, Inner1...) 转为 ID ---
    function mapNameToId(nameStr) {
        if (!nameStr) return null;
        const upper = nameStr.toUpperCase();
        if (upper === 'TOP') return 1;
        if (upper === 'BOTTOM') return 2;
        // 匹配 Inner1, Inner2 ...
        const m = upper.match(/INNER(\d+)/);
        if (m) {
            return 14 + parseInt(m[1]); // Inner1 -> 15, Inner2 -> 16
        }
        return null;
    }

    // --- [新增] UUID 生成辅助函数 (无连字符格式) ---
    function generateUUID() {
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    // --- [新增] Blob 下载辅助函数 ---
    function downloadBlobAsFile(blob, fileName) {
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(link.href);
    }

    // --- [新增] 全局日志工具函数 ---
    function appLog(msg) {
        const area = document.getElementById('debug-source-area');
        if (!area) return;
        
        const now = new Date();
        // const yyyy = now.getFullYear();
        // const mm = String(now.getMonth() + 1).padStart(2, '0');
        // const dd = String(now.getDate()).padStart(2, '0');
        const hh = String(now.getHours()).padStart(2, '0');
        const min = String(now.getMinutes()).padStart(2, '0');
        const ss = String(now.getSeconds()).padStart(2, '0');
        
        // const timeStr = `${yyyy}/${mm}/${dd} ${hh}:${min}:${ss}`;
        const timeStr = `${hh}:${min}:${ss}`;
        area.value += `${timeStr} ${msg}\n`;
        
        // 自动滚动到底部
        area.scrollTop = area.scrollHeight;
    }


    // 判断是否为 Gerber 文件
    function isGerberText(name) {
        const ext = name.split('.').pop().toLowerCase();
        if(['json', 'png', 'jpg', 'pdf', 'doc'].includes(ext)) return false;
        return true; 
    }

    // 计算最大 ID 
    function calculateMaxId(source, version) {
        // 安全检查
        // if (!source) return { ticket: 10000, id: 10000 };

        let maxTicket = 0;
        let maxIdNum = 0;

        // 统一判断版本逻辑 (兼容传入 'pro_v3', 'V3专业版' 等情况)
        const isV3 = version && (version.includes('V3') || version === 'pro_v3');

        if (isV3) {
            // =========================
            // V3 源码处理逻辑
            // =========================

            // 1. 获取最大 ticket
            // 正则匹配: "ticket":167 或 "ticket": 167
            const ticketRegex = /"ticket"\s*:\s*(\d+)/g;
            let tMatch;
            while ((tMatch = ticketRegex.exec(source)) !== null) {
                const val = parseInt(tMatch[1], 10);
                if (!isNaN(val) && val > maxTicket) {
                    maxTicket = val;
                }
            }

            // 2. 获取最大 id (仅限 e+数值 格式)
            // 正则匹配: "id":"e27"
            const idRegex = /"id"\s*:\s*"e(\d+)"/g;
            let iMatch;
            while ((iMatch = idRegex.exec(source)) !== null) {
                const val = parseInt(iMatch[1], 10);
                if (!isNaN(val) && val > maxIdNum) {
                    maxIdNum = val;
                }
            }

            return {
                ticket: maxTicket + 100,
                id: maxIdNum + 100
            };

        } else {
            // =========================
            // V2 源码处理逻辑
            // =========================
            
            // V2 格式通常为数组 ["STRING","e41",...]
            // 我们全局搜索带引号的 "e+数字" 格式即可覆盖
            const idRegex = /"e(\d+)"/g;
            let match;
            while ((match = idRegex.exec(source)) !== null) {
                const val = parseInt(match[1], 10);
                if (!isNaN(val) && val > maxIdNum) {
                    maxIdNum = val;
                }
            }

            return {
                ticket: null,
                id: maxIdNum + 100
            };
        }
    }

    // 文件选择 input 回调
    function handleFileSelect(e) { handleFiles(e.target.files); }

    // 浏览器下载文件
    function downloadStringAsFile(content, fileName) {
        const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        link.click();
        URL.revokeObjectURL(link.href);
    }

    // 复制功能  ---
    function copyDebugSource() {
        const area = document.getElementById('debug-source-area');
        if (!area) return;
        
        area.select();
        document.execCommand('copy'); 
        
        // [修复] 通过 ID 精准获取“复制”按钮，而不是获取第一个按钮
        const btn = document.getElementById('btn-debug-copy');
        if (btn) {
            const oldText = btn.textContent;
            btn.textContent = "已复制";
            
            // 1秒后恢复文字
            setTimeout(() => {
                btn.textContent = oldText;
            }, 1000);
        }
    }


    // --- 辅助：获取当前环境信息 ---
    function getEnvInfo() {
        let clientVer = 'browser';
        let isEdaEnv = false;

        if (typeof eda !== 'undefined') {
            isEdaEnv = true;
            const verStr = eda.sys_Environment.getEditorCurrentVersion(); // "2.2.45.5"
            if (verStr.startsWith('2')) clientVer = 'pro_v2';
            else if (verStr.startsWith('3')) clientVer = 'pro_v3';
        }
        return { clientVer, isEdaEnv };
    }



// ====================================================================================
// 6. 业务逻辑控制器 (Logic Controllers)
// ====================================================================================

    // handleFiles (文件入口)。
    async function handleFiles(files) {
        document.getElementById('loading-overlay').style.display = 'flex';
        rawFilesCache = []; 
        
        // 重置状态
        currentZipName = null; 
        flyingProbeData = null; // --- [新增] 重置网络数据 ---

        try {
            // --- 阶段一：读取所有文件内容 ---
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const fileNameLower = file.name.toLowerCase();

                appLog(`导入文件：${file.name}`);

                // === 情况 A: 处理 ZIP 压缩包 ===
                if (fileNameLower.endsWith('.zip')) {
                    currentZipName = file.name.replace(/\.zip$/i, '');
                    
                    const zip = await JSZip.loadAsync(file);
                    const entries = Object.keys(zip.files).filter(n => !zip.files[n].dir);
                    
                    for (let name of entries) {
                        // --- [新增] 拦截 FlyingProbeTesting.json ---
                        if (name.toLowerCase().endsWith('flyingprobetesting.json')) {
                            try {
                                const jsonStr = await zip.files[name].async("string");
                                flyingProbeData = JSON.parse(jsonStr);
                                // console.log("成功加载网络文件:", flyingProbeData);
                            } catch (e) {
                                console.error("网络文件解析失败:", e);
                            }
                            continue; // 拦截成功，跳过后续步骤（不作为图层显示）
                        }

                        // 常规 Gerber 处理
                        const content = await zip.files[name].async("string");
                        if (isGerberText(name)) rawFilesCache.push({ name, content });
                    }
                } 
                
                // === 情况 B: 处理散文件 ===
                else {
                    // --- [新增] 拦截 FlyingProbeTesting.json ---
                    if (fileNameLower === 'flyingprobetesting.json') {
                        try {
                            const jsonStr = await file.text();
                            flyingProbeData = JSON.parse(jsonStr);
                            // console.log("成功加载网络文件:", flyingProbeData);
                        } catch (e) {
                            console.error("网络文件解析失败:", e);
                        }
                        continue; // 拦截成功，不存入 rawFilesCache
                    }

                    // 常规 Gerber 处理
                    const content = await file.text();
                    rawFilesCache.push({ name: file.name, content });
                }
            }

            // --- 阶段二：全量自动检测 (保持原样) ---
            let detectedG = { int: null, dec: null }; 
            let detectedD = { int: null, dec: null }; 
            let detectedSource = 'other';
            let detectedGraphicUnit = 'mm'; 
            let detectedDrillUnit = 'mm'; 

            for (const file of rawFilesCache) {
                 const content = file.content;
                 if (content.includes("EasyEDA Pro")) detectedSource = 'easyedapro';
                 
                 if (content.match(/(?:^|\n)(?:%MOIN|G70)/) || content.includes("Units: Imperial")) detectedGraphicUnit = 'in';

                 if (content.indexOf('M48') !== -1 || file.name.match(/\.(drl|txt|xln)$/i)) {
                    if (content.match(/INCH|M72/i)) detectedDrillUnit = 'in';
                    else if (content.match(/METRIC|M71/i)) detectedDrillUnit = 'mm';
                }

                const g04Match = content.match(/(\d+)\s*integers\s+(?:and\s+)?(\d+)\s+decimals/i);
                if (g04Match && !detectedG.int) {
                    detectedG.int = parseInt(g04Match[1]);
                    detectedG.dec = parseInt(g04Match[2]);
                }
                if (!detectedG.int) {
                    const fsMatch = content.match(/%FS[LTAI]*[XY](\d)(\d)/i);
                    if (fsMatch) {
                        detectedG.int = parseInt(fsMatch[1]);
                        detectedG.dec = parseInt(fsMatch[2]);
                    }
                }

                if (!detectedD.int && (content.indexOf('M48') !== -1 || file.name.match(/\.(drl|txt|xln)$/i))) {
                    const drillMatch = content.match(/(?:METRIC|INCH).*?,([0-9\.]+)/i);
                    if (drillMatch) {
                        const fmtStr = drillMatch[1]; 
                        if (fmtStr.includes('.')) {
                            const parts = fmtStr.split('.');
                            detectedD.int = parts[0].length;
                            detectedD.dec = parts[1].length;
                        }
                    }
                }
            }
            
            // ... (UI 同步与 processRawFiles 调用，保持不变) ...
            const sourceSelect = document.getElementById('cfg-source-type');
            if (sourceSelect) sourceSelect.value = detectedSource;

            document.getElementById('cfg-units').value = detectedGraphicUnit;
            document.getElementById('cfg-d-units').value = detectedDrillUnit;
            
            if (window.setUnitUI) {
                setUnitUI(detectedGraphicUnit, 'graphic');
                setUnitUI(detectedDrillUnit, 'drill');
            }

            if (detectedG.int && detectedG.dec) {
                document.getElementById('cfg-g-int').value = detectedG.int;
                document.getElementById('cfg-dec').value = detectedG.dec;
            }
            if (detectedD.int && detectedD.dec) {
                document.getElementById('cfg-d-int').value = detectedD.int;
                document.getElementById('cfg-d-dec').value = detectedD.dec;
            }
            if (window.syncUiFromState) window.syncUiFromState();

            const finalConfig = {
                units: document.getElementById('cfg-units').value,
                drillUnits: document.getElementById('cfg-d-units').value,
                gInt: parseInt(document.getElementById('cfg-g-int').value) || 2,
                gDec: parseInt(document.getElementById('cfg-dec').value) || 5,
                dInt: parseInt(document.getElementById('cfg-d-int').value) || 2,
                dDec: parseInt(document.getElementById('cfg-d-dec').value) || 4
            };
            processRawFiles(finalConfig);

            appLog(`渲染完成`);

        } catch (e) {
            console.error(e);
            alert("加载失败: " + e.message);
        } finally {
            document.getElementById('loading-overlay').style.display = 'none';
        }
    }
    
    // processRawFiles, autoDetectSettings (处理流程)。
    function processRawFiles(configOverride) {
        loadedFiles = [];
        document.getElementById('layer-list-content').innerHTML = '';

        rawFilesCache.forEach((fileObj) => {
            const parseResult = parser.parse(fileObj.content, configOverride);
            if (parseResult.commands.length === 0) return; 

            let matchedId = 57; 
            for (let rule of fileNameRules) { if (rule.regex.test(fileObj.name)) { matchedId = rule.layerId; break; } }
            
            // --- [新增/修改] 针对埋盲孔 (ID 502) 的自动识别逻辑 ---
            let detectedStart = null;
            let detectedEnd = null;

            if (matchedId === 502) {
                // 匹配格式: ..._Top_to_Inner1... 或 ..._Inner1_to_Inner4...
                // 正则捕获组: (Top|Bottom|Inner\d+)
                const pattern = /_?(Top|Bottom|Inner\d+)_to_(Top|Bottom|Inner\d+)/i;
                const match = fileObj.name.match(pattern);
                if (match) {
                    detectedStart = mapNameToId(match[1]);
                    detectedEnd = mapNameToId(match[2]);
                    console.log(`自动识别埋盲孔层对: ${fileObj.name} -> ${match[1]}(${detectedStart}) to ${match[2]}(${detectedEnd})`);
                }
            }

            loadedFiles.push({
                name: fileObj.name,
                layerId: matchedId,
                // [修改] 默认不勾选钻孔图层 (ID 56)
                visible: matchedId !== 56, 
                index: loadedFiles.length,
                data: parseResult,
                // [新增] 存储层对信息
                pairStart: detectedStart, 
                pairEnd: detectedEnd
            });
        });

        // 1. 排序
        sortLoadedFiles();

        // 2. 自动检测设置
        autoDetectSettings();

        // 3. 调整视图与渲染
        autoFitView();
        renderLayerTable(); 
        drawCanvas();
        // --- [新增] 更新板子属性面板 ---
        updateBoardStats();


        // --- [新增] DEBUG模式下自动转换并输出源码 ---
        if (typeof DEBUG !== 'undefined' && DEBUG) {
            // 延迟一点执行，确保数据就绪
            setTimeout(() => {
                // 默认以 V2 格式预览

                const config = {
                    mode: 'debug',           // 模式：注入画布
                    targetVer: 'pro_v2', // 目标版本：跟随当前编辑器版本
                    sourceType: 'easyedapro',   // 来源
                    tryNetlist: document.getElementById('cfg-netlist').checked, // 尝试生成网络
                    importMethod: 'api'      // [新增] 导入方式: 'source' 或 'api'
                };

                exportForEasyEDA_Pro(config);
            }, 100);
        }

    }

    // [新增] 自动检测层数与板子类型
    function autoDetectSettings() {
        if (!loadedFiles || loadedFiles.length === 0) return;

        let maxInnerId = 0;
        let hasStiffener = false;
        let hasTop = false;     // 新增：标记是否有顶层
        let hasBottom = false;  // 新增：标记是否有底层

        // 1. 遍历文件特征
        loadedFiles.forEach(f => {
            const id = f.layerId;
            
            // 检测 Top/Bottom (ID 1, 2)
            if (id === 1) hasTop = true;
            if (id === 2) hasBottom = true;

            // 检测内层 (ID 15 ~ 46)
            if (id >= 15 && id <= 46) {
                if (id > maxInnerId) maxInnerId = id;
            }
            
            // 检测补强层 (ID 58: Top Stiffener, 59: Bottom Stiffener)
            if (id === 58 || id === 59) {
                hasStiffener = true;
            }
        });

        // 2. 自动设置板子类型 (FPC/PCB)
        if (hasStiffener) {
            setBoardType('FPC'); 
        } else {
            setBoardType('PCB');
        }

        // 3. 自动设置铜层数
        const layerSelect = document.getElementById('cfg-copper-layers');
        if (layerSelect) {
            let targetLayerCount = 1; // 默认初始值设为 1

            if (maxInnerId > 0) {
                // 如果有内层，按之前的逻辑计算 (2 + 内层偶数块) -> 4, 6, 8...
                // Inner1 (ID 15) -> index 1 -> ceil(0.5)*2 = 2 -> 2+2=4
                const innerIndex = maxInnerId - 14; 
                const requiredInnerBlock = Math.ceil(innerIndex / 2) * 2;
                targetLayerCount = 2 + requiredInnerBlock;
            } else {
                // 没有内层，根据顶底存在情况判断
                if (hasTop && hasBottom) {
                    targetLayerCount = 2; // 双面板
                } else if (hasTop || hasBottom) {
                    targetLayerCount = 1; // 单面板
                } else {
                    // 既无顶也无底 (例如只导入了 Drill 或 Silk)，默认归为 1 层
                    targetLayerCount = 1;
                }
            }

            // 设置下拉框的值
            layerSelect.value = targetLayerCount;
        }
    }

    /**
     * --- [新增] 从 EDA 获取当前板子 Gerber ---
     */
    async function importCurrentGerber() {
        if (typeof eda === 'undefined') {
            alert("未检测到嘉立创 EDA 环境，无法使用此功能。");
            return;
        }

        const overlay = document.getElementById('loading-overlay');
        overlay.textContent = "正在从 EDA 获取 Gerber...";
        overlay.style.display = 'flex';

        try {
            // 1. 调用 API 获取 ZIP 文件对象
            // 该 API 返回标准的 File 对象 (application/zip)
            const zipFile = await eda.pcb_ManufactureData.getGerberFile();

            if (zipFile) {
                console.log("获取成功:", zipFile.name, zipFile.size);
                
                // 2. 复用现有的 handleFiles 逻辑
                // handleFiles 接受 FileList 或数组，我们构造一个数组传进去
                await handleFiles([zipFile]);
            } else {
                alert("获取失败：API 返回了空文件。请确保 PCB 文档已打开。");
                overlay.style.display = 'none';
            }

        } catch (e) {
            console.error(e);
            alert("获取 Gerber 异常: " + e.message);
            overlay.style.display = 'none';
        }
    }

    /**
     * --- 6. PDF 导出功能模块 (逻辑修正版) ---
     */
    window.exportPDF = async (mode) => {
        if (loadedFiles.length === 0) {
            alert("请先加载 Gerber 文件");
            return;
        }

        // [新增] 计时
        const startTime = performance.now();

        const overlay = document.getElementById('loading-overlay');
        overlay.textContent = "正在准备 PDF 0%...";
        overlay.style.display = 'flex';

        // 给 UI 一点渲染时间
        await new Promise(r => setTimeout(r, 50));

        let savedState = null;

        try {
            // 1. 确定要导出的目标图层列表 & 用于计算尺寸的图层列表
            let targetLayers = []; // 实际要渲染的层
            let boundsLayers = []; // 用于计算包围盒的层

            if (mode === 'single') {
                // [当前内容]：合成渲染，只计算可见层尺寸
                targetLayers = null; // 特殊标记：不需要循环单独渲染
                boundsLayers = loadedFiles.filter(f => f.visible);
            } 
            else if (mode === 'multi') {
                // [启用图层]：只导出可见层，每层一页
                targetLayers = loadedFiles.filter(f => f.visible);
                boundsLayers = targetLayers;
            } 
            else if (mode === 'all') {
                // [全部图层]：导出所有层，每层一页
                targetLayers = loadedFiles;
                boundsLayers = loadedFiles; // 必须计算所有层的尺寸，防止隐藏的大层被裁切
            }

            if (boundsLayers.length === 0) {
                throw new Error("没有可导出的图层 (请至少启用一个图层)");
            }

            // 2. 备份当前视图状态 (用于导出后恢复)
            savedState = {
                w: mainCanvas.width, 
                h: mainCanvas.height,
                scale: viewState.scale,
                offsetX: viewState.offsetX, 
                offsetY: viewState.offsetY,
                visibility: loadedFiles.map(f => f.visible) // 备份可见性状态
            };

            // 3. 计算包围盒 (基于 boundsLayers)
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            
            boundsLayers.forEach(f => {
                const b = f.data.bounds;
                if (b.minX !== Infinity) {
                    minX = Math.min(minX, b.minX); maxX = Math.max(maxX, b.maxX);
                    minY = Math.min(minY, b.minY); maxY = Math.max(maxY, b.maxY);
                }
            });

            if (minX === Infinity) throw new Error("无法获取板子尺寸");

            
            // 4. 定义 PDF 物理尺寸 (英寸)
            const paddingInches = 0.7; // 固定 0.7 英寸边距
            
            // 将板子尺寸从 mm 转换为 inch
            const boardW_in = (maxX - minX) / 25.4;
            const boardH_in = (maxY - minY) / 25.4;
            
            // 加上边距的预期尺寸
            const raw_pdfW_in = boardW_in + (paddingInches * 2);
            const raw_pdfH_in = boardH_in + (paddingInches * 2);

            // 5. 读取 DPI 并计算画布像素
            const uiDpiVal = document.getElementById('cfg-dpi') ? document.getElementById('cfg-dpi').value : '1200';
            const targetDPI = parseInt(uiDpiVal) || 1200;

            // 像素 = 原始英寸 * DPI (向上取整)
            const canvasW = Math.ceil(raw_pdfW_in * targetDPI);
            const canvasH = Math.ceil(raw_pdfH_in * targetDPI);

            // 反向计算最终精确的 PDF 英寸尺寸 (避免像素取整误差导致比例不对)
            const final_pdfW_in = canvasW / targetDPI;
            const final_pdfH_in = canvasH / targetDPI;

            // 调整 Canvas 大小以匹配高分辨率
            mainCanvas.width = canvasW;
            mainCanvas.height = canvasH;
            bufferCanvas.width = canvasW;
            bufferCanvas.height = canvasH;

            // CSS 视觉缩放 (防止页面布局被撑大)
            const container = document.getElementById('canvas-container');
            const contW = container.clientWidth;
            const contH = container.clientHeight;
            // 保持比例居中显示
            const displayRatio = Math.min(contW / canvasW, contH / canvasH);
            
            mainCanvas.style.width = `${canvasW * displayRatio}px`;
            mainCanvas.style.height = `${canvasH * displayRatio}px`;
            mainCanvas.style.marginLeft = `${(contW - canvasW * displayRatio) / 2}px`;
            mainCanvas.style.marginTop = `${(contH - canvasH * displayRatio) / 2}px`;

            // 6. 计算渲染参数 (视图变换)
            const pixelScale = targetDPI / 25.4; 
            // 计算居中偏移
            const effectivePaddingW_Px = (canvasW - ((maxX - minX) * pixelScale)) / 2;
            const effectivePaddingH_Px = (canvasH - ((maxY - minY) * pixelScale)) / 2;

            // 应用到 ViewState
            viewState.scale = pixelScale;
            viewState.offsetX = effectivePaddingW_Px - (minX * pixelScale);
            viewState.offsetY = effectivePaddingH_Px + (maxY * pixelScale);

            // 7. 初始化 PDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: final_pdfW_in > final_pdfH_in ? 'l' : 'p',
                unit: 'in', 
                format: [final_pdfW_in, final_pdfH_in]
            });

            // 辅助：黑底绘图函数
            const drawWithBlackBg = () => {
                drawCanvas(true); 
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.globalCompositeOperation = 'destination-over'; 
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvasW, canvasH);
                ctx.restore();
            };
            
            // --- 8. 开始渲染 ---
            
            if (mode === 'single') {
                appLog(`正在生成当前视图...`);
                // === 模式 A: 单页合成 (当前可视内容) ===
                overlay.textContent = "正在渲染视图...";
                await new Promise(r => setTimeout(r, 10));

                drawWithBlackBg();
                appLog(`-----------------------`);
                overlay.textContent = "正在生成 PDF...";
                await new Promise(r => setTimeout(r, 10));

                const imgData = mainCanvas.toDataURL('image/jpeg', 1.0);
                doc.addImage(imgData, 'JPEG', 0, 0, final_pdfW_in, final_pdfH_in);
            
            } else {
                // === 模式 B & C: 多页分页 (启用图层 或 全部图层) ===
                const total = targetLayers.length;
                
                for (let i = 0; i < total; i++) {
                    const file = targetLayers[i];
                    appLog(`正在生成 ${file.name}`); // 或者 appLog(`正在生成第 ${i+1} 层`);
                    const percent = Math.round(((i) / total) * 100);
                    overlay.textContent = `正在处理图层 ${percent}% (${i + 1}/${total})`;
                    await new Promise(r => setTimeout(r, 0));

                    // 1. 隔离显示当前图层
                    loadedFiles.forEach(f => f.visible = false);
                    file.visible = true;

                    // 2. 绘制
                    drawWithBlackBg();

                    // 3. 绘制水印标签 (黄色文字)
                    ctx.setTransform(1, 0, 0, 1, 0, 0); 
                    ctx.fillStyle = '#FFFF00'; 
                    ctx.font = `bold ${3 * pixelScale}px "Segoe UI", sans-serif`; 
                    ctx.textBaseline = 'top';
                    ctx.textAlign = 'left';
                    const label = `[${i+1}] ${file.name}  (${layerIdMap[file.layerId] || 'Unknown Layer'})`;
                    ctx.fillText(label, 5 * pixelScale, 3 * pixelScale);

                    // 4. 添加到 PDF
                    const imgData = mainCanvas.toDataURL('image/jpeg', 1.0);
                    if (i > 0) doc.addPage([final_pdfW_in, final_pdfH_in]); 
                    doc.addImage(imgData, 'JPEG', 0, 0, final_pdfW_in, final_pdfH_in);
                }
            }
            
            overlay.textContent = "正在保存文件...";
            await new Promise(r => setTimeout(r, 10));
            
            // --- [修改] 文件名生成逻辑 ---
            let fileName = "";
            const timestamp = new Date().getTime();
            
            if (currentZipName) {
                // 如果是 ZIP 导入，使用：压缩包名_模式_时间戳.pdf
                fileName = `${currentZipName}_${mode}_${timestamp}.pdf`;
            } else {
                // 否则使用默认：Gerber_Export_模式_时间戳.pdf
                fileName = `Gerber_Export_${mode}_${timestamp}.pdf`;
            }

            // [新增] 结束计时日志
            const endTime = performance.now();
            const duration = ((endTime - startTime) / 1000).toFixed(2);
            appLog(`数据生成完毕，耗时${duration}秒`);

            doc.save(fileName);

        } catch (e) {
            console.error(e);
            appLog(`PDF生成失败: ${e.message}`);
            alert("导出 PDF 失败: " + e.message);
        } finally {
            // 9. 恢复现场 (非常重要)
            if (savedState) {
                // 恢复画布尺寸
                mainCanvas.width = savedState.w;
                mainCanvas.height = savedState.h;
                bufferCanvas.width = savedState.w;
                bufferCanvas.height = savedState.h;
                
                // 清除 CSS 样式
                mainCanvas.style.width = '';
                mainCanvas.style.height = '';
                mainCanvas.style.marginLeft = '';
                mainCanvas.style.marginTop = '';

                // 恢复视图参数
                viewState.scale = savedState.scale;
                viewState.offsetX = savedState.offsetX;
                viewState.offsetY = savedState.offsetY;
                
                // 恢复图层可见性
                loadedFiles.forEach((f, i) => f.visible = savedState.visibility[i]);
                
                // 重绘
                drawCanvas();
            }
            overlay.style.display = 'none';
        }
    };



    // --- 1.1 按钮：导出至当前 PCB 画布 (修改版) ---
    window.handleExportToCanvas = async (method) => {
        const env = getEnvInfo();
        const sourceType = document.getElementById('cfg-source-type').value;

        // if (!env.isEdaEnv) {
        //     alert("此功能仅在嘉立创 EDA 专业版客户端环境中可用。");
        //     return;
        // }

        // 如果是通过API导入，使用V2版本源码方便提取参数
        if(method === 'api'){
            env.clientVer = 'pro_v2';
        }

        const config = {
            mode: 'canvas',           // 模式：注入画布
            targetVer: env.clientVer, // 目标版本：跟随当前编辑器版本
            sourceType: sourceType,   // 来源
            tryNetlist: document.getElementById('cfg-netlist').checked, // 尝试生成网络
            importMethod: method      // [新增] 导入方式: 'source' 或 'api'
        };

        if (sourceType === 'easyedapro'){
            await exportForEasyEDA_Pro(config);
        } else {
            await exportForOther_Pro(config); 
        }
    };

    // --- 1.2 按钮：导出标准版文件 (下载逻辑) ---
    window.handleExportStandard = async () => {
        const sourceType = document.getElementById('cfg-source-type').value;
        const config = {
            mode: 'file',//导出文件
            targetVer: 'std',//标准版
            sourceType: sourceType, //来源
            tryNetlist: document.getElementById('cfg-netlist').checked // 尝试生成网络
        };

        await exportForStandard(config);
    };

    // --- 1.3 按钮：导出专业版 V2 文件 (下载逻辑) ---
    window.handleExportProV2 = async () => {
        const sourceType = document.getElementById('cfg-source-type').value;
        const config = {
            mode: 'file',//导出文件
            targetVer: 'pro_v2',//专业版V2
            sourceType: sourceType, //来源
            tryNetlist: document.getElementById('cfg-netlist').checked // 尝试生成网络
        };

        if (sourceType === 'easyedapro'){
            await exportForEasyEDA_Pro(config);
        }else{
            await exportForOther_Pro(config); 
        }
    };

    // --- 1.4 按钮：导出专业版 V3 文件 (下载逻辑) ---
    window.handleExportProV3 = async () => {
        const sourceType = document.getElementById('cfg-source-type').value;
        const config = {
            mode: 'file',//导出文件
            targetVer: 'pro_v3',//专业版V3
            sourceType: sourceType, //来源
            tryNetlist: document.getElementById('cfg-netlist').checked // 尝试生成网络
        };

        if (sourceType === 'easyedapro'){
            await exportForEasyEDA_Pro(config);
        }else{
            await exportForOther_Pro(config); 
        }
    };

    // --- [修改] 动态配置头文件函数 ---
    function configureHeader(source, isV3) {
        const copperCountEl = document.getElementById('cfg-copper-layers');
        const copperCount = copperCountEl ? (parseInt(copperCountEl.value) || 2) : 2;
        const neededInner = Math.max(0, copperCount - 2);

        const getLyrIdx = (id) => {
            if (id === 1) return 1;
            if (id === 2) return copperCount; 
            if (id >= 15 && id <= 46) return (id - 15) + 2; 
            return null;
        };

        // 2. 提取埋盲孔规则
        const blindFiles = loadedFiles.filter(f => f.layerId === 502 && f.pairStart && f.pairEnd);
        const blindRules = [];
        const seenRules = new Set();

        blindFiles.forEach(f => {
            const sId = f.pairStart;
            const eId = f.pairEnd;
            const sIdx = getLyrIdx(sId);
            const eIdx = getLyrIdx(eId);

            if (sIdx !== null && eIdx !== null) {
                const startPhys = Math.min(sIdx, eIdx);
                const endPhys = Math.max(sIdx, eIdx);
                const startID = (sIdx < eIdx) ? sId : eId;
                const endID   = (sIdx < eIdx) ? eId : sId;
                const ruleName = `${startPhys}-${endPhys}`;
                const uniqueKey = `${startID}-${endID}`;

                if (!seenRules.has(uniqueKey)) {
                    seenRules.add(uniqueKey);
                    blindRules.push({ name: ruleName, start: startID, end: endID });
                }
            }
        });
        
        if (isV3) {
            console.log(`[V3 Config] 1. 盲埋孔规则准备就绪: ${blindRules.length} 条`, blindRules);
        }

        const lines = source.split('\n');
        
        const newLines = lines.map((line, lineIdx) => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return line;

            // === V3 处理逻辑 ===
            if (isV3) {
                const parts = trimmedLine.split("||");
                if (parts.length < 2) return line;

                let meta, content;
                try {
                    meta = JSON.parse(parts[0]);
                    
                    // [修复] 更安全的去尾逻辑
                    let contentStr = parts[1];
                    // 去除末尾所有空白和竖线
                    contentStr = contentStr.trim();
                    if (contentStr.endsWith('|')) {
                        contentStr = contentStr.substring(0, contentStr.length - 1);
                    }
                    content = JSON.parse(contentStr);
                    
                } catch (e) {
                    // [调试] 如果解析失败，打印出来
                    console.error(`[V3 Config] 解析错误 (行 ${lineIdx}):`, e.message, line.substring(0, 50) + "...");
                    return line; 
                }

                let isModified = false;

                try {
                    // A. 修改图层启用状态
                    if (meta.type === "LAYER" && typeof content.layerId === 'number') {
                        if (content.layerId >= 15 && content.layerId <= 46) {
                            const innerIndex = content.layerId - 14; 
                            const isEnabled = innerIndex <= neededInner;
                            if (content.use !== isEnabled) {
                                content.use = isEnabled;
                                content.show = isEnabled;
                                isModified = true;
                            }
                        }
                    }

                    // B. 修改埋盲孔规则
                    if (meta.type === "RULE") {
                        const idStr = JSON.stringify(meta.id || "");
                        
                        // [调试] 打印遇到的每一个规则 ID，确认是否扫描到了 blindVia
                        // console.log(`[V3 Config] 扫描规则: ${idStr}`);

                        // 宽松匹配：ID包含 blind，或者内容里有 blinds 字段
                        const isBlindRule = idStr.toLowerCase().includes("blind") || (content.ruleContext && content.ruleContext.blinds);

                        if (isBlindRule) {
                            console.log(`[V3 Config] 2. 命中盲埋孔规则行! ID: ${idStr}`);
                            
                            const v3BlindContent = blindRules.map(r => ({
                                "name": r.name,
                                "staLayerId": r.start,
                                "endLayerId": r.end,
                                "viaSizeRule": ""
                            }));
                            
                            // 确保结构路径存在 (防御性编程)
                            if (!content.ruleContext) content.ruleContext = {};
                            if (!content.ruleContext.blinds) content.ruleContext.blinds = {};
                            
                            console.log(`[V3 Config] 3. 注入数据:`, JSON.stringify(v3BlindContent));
                            
                            content.ruleContext.blinds.content = v3BlindContent;
                            isModified = true;
                        }
                    }

                } catch (err) {
                    console.error(`[V3 Config] 逻辑处理异常 (行 ${lineIdx}):`, err);
                    return line; // 发生逻辑错误返回原行
                }

                if (isModified) {
                    // [调试] 确认修改
                    if (meta.type === "RULE") {
                        console.log(`[V3 Config] 4. 规则行修改成功，重新打包`);
                    }
                    return JSON.stringify(meta) + "||" + JSON.stringify(content) + "|";
                } else {
                    return line;
                }

            } else {
                // === V2 处理逻辑 (保持不变) ===
                let arr;
                try { arr = JSON.parse(line); } catch (e) { return line; }

                if (arr[0] === "LAYER" && typeof arr[1] === 'number') {
                    const id = arr[1];
                    if (id >= 15 && id <= 46) {
                        const innerIndex = id - 14;
                        const isEnabled = innerIndex <= neededInner;
                        arr[4] = isEnabled ? 3 : 0; 
                        return JSON.stringify(arr);
                    }
                }

                if (arr[0] === "RULE" && arr[2] === "blindVia") {
                    const v2BlindContent = blindRules.map(r => [r.name, r.start, r.end]);
                    arr[4] = v2BlindContent;
                    return JSON.stringify(arr);
                }
                return line;
            }
        });

        return newLines.join('\n');
    }

    // --- [新增] 通过 API 配置盲埋孔规则 ---
    async function configureBlindViasAPI() {
        // 1. 检查是否有需要配置的盲埋孔文件
        const blindFiles = loadedFiles.filter(f => f.layerId === 502 && f.pairStart && f.pairEnd);
        if (blindFiles.length === 0) return;

        appLog("正在检测设计规则配置...");

        try {
            // 2. 获取当前设计规则
            const currentConfigObj = await eda.pcb_Drc.getCurrentRuleConfiguration();
            
            if (!currentConfigObj || !currentConfigObj.config) {
                console.warn("无法获取设计规则配置");
                return;
            }

            // 定位到 Blind/Buried Via 节点
            // 路径: config -> Physics -> "Blind/Buried Via" -> blindVia -> table
            const physics = currentConfigObj.config.Physics;
            if (!physics || !physics["Blind/Buried Via"] || !physics["Blind/Buried Via"].blindVia) {
                console.warn("设计规则中未找到盲埋孔配置节点");
                return;
            }

            const targetNode = physics["Blind/Buried Via"].blindVia;
            
            // 3. 构建新的规则表
            // 获取总层数用于计算物理层名称 (如 "1-2")
            const copperCountEl = document.getElementById('cfg-copper-layers');
            const totalLayers = copperCountEl ? (parseInt(copperCountEl.value) || 2) : 2;

            const getPhysIdx = (id) => {
                if (id === 1) return 1;
                if (id === 2) return totalLayers;
                if (id >= 15 && id <= 46) return (id - 15) + 2;
                return 0;
            };

            const newTable = [];
            const seenKeys = new Set();

            blindFiles.forEach((f, idx) => {
                const sId = f.pairStart;
                const eId = f.pairEnd;
                
                // 确保层 ID 有效
                if (!sId || !eId) return;

                // 简单的去重键
                const uniqueId = `${Math.min(sId, eId)}-${Math.max(sId, eId)}`;
                
                if (!seenKeys.has(uniqueId)) {
                    seenKeys.add(uniqueId);

                    // 计算物理层名称 (例如 "1-2")
                    const sPhys = getPhysIdx(sId);
                    const ePhys = getPhysIdx(eId);
                    const name = `${Math.min(sPhys, ePhys)}-${Math.max(sPhys, ePhys)}`;

                    // 构造符合 API 定义的对象
                    newTable.push({
                        "name": name,
                        "startLayer": sId, // API 需要 layerId
                        "endLayer": eId,   // API 需要 layerId
                        "used": true,      // 标记为使用
                        "key": `generated_blind_${Date.now()}_${idx}`, // 生成唯一 Key 防止冲突
                        "viaSizeRule": ""  // 默认无特定尺寸规则
                    });
                }
            });

            // 4. 应用修改
            // 策略：保留原有的规则？还是覆盖？
            // 考虑到这是导入操作，建议将新规则追加到现有规则中，或者如果完全确信是新板子则覆盖。
            // 这里采用：追加并去重（根据 name）
            
            const existingTable = targetNode.table || [];
            // 过滤掉名字冲突的旧规则，保留我们的新规则
            const mergedTable = [
                ...existingTable.filter(old => !newTable.some(nw => nw.name === old.name)),
                ...newTable
            ];

            targetNode.table = mergedTable;

            // 5. 保存配置
            const configName = currentConfigObj.name || "自定义配置";
            appLog(`正在更新盲埋孔规则 (${newTable.length} 组新增)...`);
            
            // 调用 saveRuleConfiguration
            // 参数3 allowOverwrite = true
            const success = await eda.pcb_Drc.saveRuleConfiguration(currentConfigObj, configName, true);
            
            if (success) {
                appLog("设计规则更新成功");
            } else {
                appLog("设计规则更新被拒绝");
            }

        } catch (e) {
            console.error("配置盲埋孔规则异常:", e);
            appLog(`配置规则失败: ${e.message}`);
        }
    }


    // 来源：嘉立创EDA -> 目标：专业版 (支持 V2 和 V3)
    async function exportForEasyEDA_Pro(config) {
        console.log("开始导出处理...", config);
        const startTime = performance.now(); // 开始计时
        
        const isV3 = config.targetVer === 'pro_v3';
        const separator = isV3 ? "|\n" : "\n"; // 提前定义分隔符
        
        // 1. 准备源码头 (移除 !DEBUG 判断，始终生成头文件)
        let rawTemplate = isV3 ? LCEDA_V3_Head_Source : LCEDA_V2_Head_Source;
        // 调用配置函数，动态修改图层和规则
        let finalSource = configureHeader(rawTemplate, isV3);
        
        // 仅在非Debug或Debug但未显示日志时记录，避免刷屏，但此处为了逻辑简单保留
        // appLog(`已根据设置动态更新文件头配置`);

        // 2. 提取数据
        // 仅导出勾选的图层
        const rawData = PadTool.extractRawData(loadedFiles.filter(f => f.visible));
        
        // 3. 聚合数据
        const unifiedData = PadTool.consolidate(
            rawData.rawPads || [], 
            rawData.rawVias || [], 
            rawData.rawTracks || [], 
            rawData.rawPolys || [], 
            rawData.rawFills || [], 
            rawData.drills || [],
            rawData.rawImages || [],
            rawData.rawTextLines || [],
            rawData.rawCoppers || []
        );
        
        // 4. 获取 ID 起始值
        const startIds = (typeof DEBUG !== 'undefined' && DEBUG) 
            ? { ticket: 200, id: 200 } 
            : calculateMaxId(finalSource, config.targetVer);

        // 5. 生成图元字符串 (这一步才真正决定了最终有多少个图元)
        const primitives = PadTool.generatePrimitives(unifiedData, {
            isV3: isV3,
            ticket: startIds.ticket || 10000,
            id: startIds.id || 10000
        }, config); 

        // --- 统计生成的图元数量 ---
        let stat_pads = 0;
        let stat_vias = 0;
        let stat_tracks = 0;
        let stat_polys = 0;
        let stat_fills = 0; 
        let stat_holes = 0;
        let stat_texts = 0;

        primitives.forEach(str => {
            if (isV3) {
                try {
                    const parts = str.split("||");
                    if(parts.length > 1) {
                        const meta = JSON.parse(parts[0]);
                        const content = JSON.parse(parts[1]);
                        const type = meta.type;
                        if (type === 'PAD') stat_pads++;
                        else if (type === 'VIA') stat_vias++;
                        else if (type === 'TRACK' || type === 'ARC' || type === 'LINE') stat_tracks++;
                        else if (type === 'STRING' || type === 'TEXT') stat_texts++;
                        else if (type === 'HOLE') stat_holes++;
                        else if (type === 'REGION' || type === 'FILL') {
                            if (content.fill || type === 'FILL') stat_fills++;
                            else stat_polys++;
                        } else if (type === 'POLY') stat_polys++;
                        else if (type === 'IMAGE') stat_fills++;
                    }
                } catch(e) {}
            } else {
                try {
                    const match = str.match(/^\["([A-Z_]+)"/);
                    if (match) {
                        const type = match[1];
                        if (type === 'PAD') stat_pads++;
                        else if (type === 'VIA') stat_vias++;
                        else if (type === 'LINE' || type === 'ARC') stat_tracks++;
                        else if (type === 'POLY') stat_polys++;
                        else if (type === 'FILL' || type === 'POURED' || type === 'IMAGE') stat_fills++;
                        else if (type === 'STRING') stat_texts++;
                        else if (type === 'HOLE') stat_holes++;
                    }
                } catch(e) {}
            }
        });

        // 输出日志
        appLog(`-----------------------`);
        appLog(`生成焊盘 ${stat_pads} 个`);
        appLog(`生成过孔 ${stat_vias} 个`);
        appLog(`生成导线 ${stat_tracks} 条`);
        appLog(`生成折线 ${stat_polys} 条`);
        appLog(`生成填充 ${stat_fills} 个`);
        appLog(`生成文本 ${stat_texts} 个`);

        // 6. 处理 DEBUG 输出 (修改点：拼接完整源码)
        if (typeof DEBUG !== 'undefined' && DEBUG) {
            if (config.mode === 'debug') {
                 const textArea = document.getElementById('debug-source-area');
                 if(textArea) {
                     // 拼接：头文件 + 分隔符 + 图元
                     let debugFullSource = finalSource;
                     if (primitives.length > 0) {
                         debugFullSource += separator + primitives.join(separator);
                     }
                     textArea.value = debugFullSource;
                 }
                 // Debug 模式下生成完源码直接返回，不进行后续的文件下载或API写入
                 return;
            }
        }

        // 7. 正式输出拼接 (非 Debug 模式，或者 Debug 模式下的文件导出)
        if (primitives.length > 0) {
            // 注意：V3 格式如果直接拼接在头文件后，需要补一个分隔符
            if (isV3) finalSource += separator + primitives.join(separator);
            else finalSource += "\n" + primitives.join("\n");
        }

        const endTime = performance.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        appLog(`数据生成完毕，耗时${duration}秒`);

        // --- 文件导出逻辑：打包 ZIP ---
        if (config.mode === 'file') {
            const zip = new JSZip();
            const timestamp = new Date().getTime();
            const baseName = currentZipName || `${timestamp}`;
            const outputName = `Gerber_To_PCB_${baseName}`;

            if (isV3) {
                const projectConfig = {
                    "title": outputName,
                    "cbb_project": false,
                    "editorVersion": "",
                    "introduction": "",
                    "description": "",
                    "tags": "[]"
                };
                zip.file(`${outputName}.epru`, finalSource);
                zip.file("project2.json", JSON.stringify(projectConfig, null, 2));
                appLog("正在打包 V3 工程文件...");
                const content = await zip.generateAsync({type:"blob"});
                downloadBlobAsFile(content, `${outputName}.epro2`);
            } else {
                const uuid = generateUUID();
                const projectConfig = {
                    "schematics": {},
                    "pcbs": {}, 
                    "panels": {},
                    "symbols": {},
                    "footprints": {},
                    "devices": {},
                    "boards": {},
                    "config": {
                        "title": "PCB1",
                        "cbbProject": false,
                        "defaultSheet": "",
                        "editorVersion": "2.2.45.5"
                    }
                };
                projectConfig.pcbs[uuid] = "PCB1";
                zip.file("project.json", JSON.stringify(projectConfig, null, 2));
                const pcbFolder = zip.folder("PCB");
                pcbFolder.file(`${uuid}.epcb`, finalSource);
                appLog("正在打包 V2 工程文件...");
                const content = await zip.generateAsync({type:"blob"});
                downloadBlobAsFile(content, `${outputName}.epro`);
            }

        } else if (config.mode === 'canvas') {
            
            const writeStartTime = performance.now();
            try {
                // 1. 获取 UI 上设定的层数 (例如 2, 4, 6...)
                const copperCountEl = document.getElementById('cfg-copper-layers');
                const targetLayerCount = copperCountEl ? (parseInt(copperCountEl.value) || 2) : 2;
                // 2. 调用 API 设置层数
                const setLayerResult = await eda.pcb_Layer.setTheNumberOfCopperLayers(targetLayerCount);
                // console.log("层数设置结果:", setLayerResult);
                
                // 稍微等待一下，确保状态更新
                // await new Promise(r => setTimeout(r, 50));

                appLog(`正在将板子设为${targetLayerCount}层板`);
                
                if (typeof eda !== 'undefined') {
                    if (config.importMethod === 'api') {
                        appLog(`写入画布中 (图元模式)...`);
                        // 在导入图元之前，先配置设计规则
                        // await configureBlindViasAPI(); // 当前保存设计规划失败，未知原因
                        await importPrimitivesAPI(primitives, isV3);
                        
                        const writeEndTime = performance.now();
                        const writeDuration = ((writeEndTime - writeStartTime) / 1000).toFixed(2);
                        appLog(`参数传递完成，耗时${writeDuration}秒`);
                        appLog(`全部参数已传递至EDA，待EDA绘制完成`);
                    } else {
                        appLog(`正在写入全量数据...`);
                        const result = await eda.sys_FileManager.setDocumentSource(finalSource);
                        const writeEndTime = performance.now();
                        const writeDuration = ((writeEndTime - writeStartTime) / 1000).toFixed(2);
                        if (result) appLog(`写入完成，耗时${writeDuration}秒`);
                        else appLog(`写入失败 (API返回false)`);
                    }
                }
            } catch (e) {
                console.error(e);
                appLog(`写入过程出错: ${e.message}`);
            }
        }
    }

    // 来源：其他 -> 目标：专业版 (支持 V2 和 V3) (保留入口)
    async function exportForOther_Pro(config) {
        // 待完善
    }

    // importPrimitivesAPI (API 写入)。
    async function importPrimitivesAPI(primitivesArr, isV3) {
        // console.log("准备通过 API 导入图元...", primitivesArr.length);
        const separator = "\n"; // 提前定义分隔符
        const textArea = document.getElementById('debug-source-area');
        let FullSource = '';
        if (primitivesArr.length > 0) {
            FullSource += separator + primitivesArr.join(separator);
        }

        // 逐行处理
        const lines = FullSource.trim().split('\n').map(line => JSON.parse(line));
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const command = line[0];
            switch (command) {
                case 'PAD': // 焊盘
                    try {
                        let holeDef = line[9];
                        if (Array.isArray(holeDef) && holeDef.length >= 3 && holeDef[0] === "SLOT") {
                            const w = holeDef[1];
                            const h = holeDef[2];
                            holeDef = ["SLOT", h, w]; // 交换 直接 长度
                        }
                        eda.pcb_PrimitivePad.create(
                            line[4],                          // layer: 层编号
                            line[5]?.toString() || "",        // padNumber: 焊盘编号，转为字符串
                            line[6],                          // x: X坐标
                            line[7],                          // y: Y坐标
                            line[8] || 0,                     // rotation: 旋转角度
                            line[10] || null,                 // pad: 默认焊盘形状
                            line[3] || "",                    // net: 网络名称
                            holeDef || null,                  // [修改] 使用处理过的 holeDef
                            line[12] || 0,                    // holeOffsetX: 孔偏移X
                            line[13] || 0,                    // holeOffsetY: 孔偏移Y
                            line[14] || 0,                    // holeRotation: 孔旋转角度
                            !!line[15],                       // metallization: 是否金属化
                            line[16] || 0,                    // padType: 焊盘类型
                            line[11] || [],                   // specialPad: 特殊焊盘
                            // 阻焊和助焊扩展
                            (line[17] !== null || line[18] !== null || line[19] !== null || line[20] !== null) ? {
                                "topSolderMask": line[17],
                                "bottomSolderMask": line[18],
                                "topPasteMask": line[19],
                                "bottomPasteMask": line[20]
                            } : null,
                            // 热焊设置
                            (line[21] !== null || line[22] !== null || line[23] !== null || line[24] !== null) ? {
                                "connectionType": line[21],
                                "divergenceSpacing": line[22],
                                "divergenceLineWidth": line[23],
                                "divergenceAngle": line[24]
                            } : null,
                            !!line[25]                        // primitiveLock: 是否锁定
                        );
                    } catch (error) {
                        console.error('创建PAD失败:', error);
                    }
                    break;
                case 'VIA': // 过孔
                    try {
                        eda.pcb_PrimitiveVia.create(
                            line[3],               // NET名称
                            line[5],               // X坐标
                            line[6],               // Y坐标
                            line[7],               // 孔直径
                            line[8],               // 焊盘直径
                            line[9] || 0,          // 过孔类型，默认普通过孔
                            line[4] || null,       // 设计规则名称（盲埋孔类型）
                            line[10] === null && line[11] === null ? null : { // 阻焊扩展
                                "topSolderMask": line[10],
                                "bottomSolderMask": line[11]
                            },
                            !!line[12]             // 是否锁定
                        );
                    } catch (error) {
                        console.error('创建VIA失败:', error);
                    }
                    break;
                case 'LINE': // 直线
                    try {
                        eda.pcb_PrimitiveLine.create(
                            line[3] || "",    // 网络名称
                            line[4],          // 层编号
                            line[5],          // 开始X坐标
                            line[6],          // 开始Y坐标
                            line[7],          // 结束X坐标
                            line[8],          // 结束Y坐标
                            line[9],          // 线宽
                            !!line[10]        // 是否锁定
                        );
                    } catch (error) {
                        console.error('创建LINE失败:', error);
                    }
                    break;
                case 'ARC': // 弧线
                    try {
                        eda.pcb_PrimitiveArc.create(
                            line[3] || "",    // 网络名称
                            line[4],          // 层编号
                            line[5],          // 起始X坐标
                            line[6],          // 起始Y坐标
                            line[7],          // 结束X坐标
                            line[8],          // 结束Y坐标
                            line[9],          // 圆弧角度
                            line[10],         // 线宽，默认0.5
                            "1",              // 交互模式，固定为"1"（两点圆弧）
                            !!line[11]        // 是否锁定
                        );
                    } catch (error) {
                        console.error('创建ARC失败:', error);
                    }
                    break;
                    
                case 'POLY': // 折线
                    try {
                        // 创建多边形对象，第6项是多边形数据
                        const polygon = eda.pcb_MathPolygon.createPolygon(line[6]);
                        
                        // 调用折线API创建折线图元
                        eda.pcb_PrimitivePolyline.create(
                            line[3] || "",                    // net: 网络名称
                            line[4] || 1,                     // layer: 层编号
                            polygon,                          // polygon: 多边形对象
                            line[5] || 0.5,                   // lineWidth: 线宽
                            !!line[7]                         // primitiveLock: 是否锁定
                        );
                    } catch (error) {
                        console.error('创建POLY失败:', error);
                    }
                    break;
                case 'FILL': // 填充
                    try {
                        // 创建多边形对象，第7项是多边形数据数组
                        const polygon = eda.pcb_MathPolygon.createPolygon(line[7]);
                        
                        // 调用填充API创建填充图元
                        eda.pcb_PrimitiveFill.create(
                            line[4],                          // layer: 层编号
                            polygon,                          // complexPolygon: 多边形对象
                            line[3] || "",                    // net: 网络名称
                            line[6] || 0,                     // fillMode: 填充模式
                            line[5] || 0.2,                   // lineWidth: 线宽（网格填充时有效）
                            !!line[8]                         // primitiveLock: 是否锁定
                        );
                    } catch (error) {
                        console.error('创建FILL失败:', error);
                    }
                    break;
                case 'IMAGE': // 图片
                    try {
                        // 创建多边形对象，第10项是多边形数据数组
                        const complexPolygon = eda.pcb_MathPolygon.createPolygon(line[10]);
                        
                        // 调用图片API创建图片图元
                        eda.pcb_PrimitiveImage.create(
                            line[4],                          // x: 左上角X坐标
                            line[5],                          // y: 左上角Y坐标
                            complexPolygon,                   // complexPolygon: 多边形对象
                            line[3] || 1,                     // layer: 层编号
                            line[6],                          // width: 宽度
                            line[7],                          // height: 高度
                            line[8] || 0,                     // rotation: 旋转角度
                            !!line[9],                        // horizonMirror: 是否水平镜像
                            !!line[11]                        // primitiveLock: 是否锁定
                        );
                    } catch (error) {
                        console.error('创建IMAGE失败:', error);
                    }
                    break;
                case 'STRING': // 文字
                    try {             
                        // 调用文字API创建文字图元
                        eda.pcb_PrimitiveString.create(
                            line[3] || 1,                 // layer: 层
                            line[4],                      // x: 位置 X
                            line[5],                      // y: 位置 Y
                            line[6] || "",                // text: 内容
                            line[7] || "default2",        // fontFamily: 字体名称
                            line[8],                      // fontSize: 字号
                            line[9],                      // lineWidth: 粗细
                            line[12] || 1,                // alignMode: 对齐模式 (索引13，跳过加粗/斜体)
                            line[13] || 0,                // rotation: 旋转角度
                            !!line[14],                   // reverse: 是否反相扩展 (转为Boolean)
                            line[15] || 0,                // expansion: 反相扩展尺寸
                            !!line[16],                   // mirror: 是否镜像 (转为Boolean)
                            !!line[17]                    // primitiveLock: 是否锁定 (转为Boolean)
                        );
                    } catch (error) {
                        console.error('创建STRING失败:', error);
                    }
                    break;
                default:
                    console.warn(`未知命令: ${command}，数据:`, line.slice(0, 3).concat('...'));
                    break;
            }
        }
    }

    // 目标：标准版 (保留入口)
    async function exportForStandard(config) {
        // 待完善
        alert('待后续更新');
    }

    // --- [新增] 手动生成 DEBUG 源码 ---
    window.generateDebugSource = async () => {
        if (loadedFiles.length === 0) {
            alert("请先导入 Gerber 文件");
            return;
        }

        const btn = document.querySelector('button[onclick="generateDebugSource()"]');
        const oldText = btn.textContent;
        btn.textContent = "生成中...";

        // 构造配置：指定生成 V3 版本，且模式为 debug (输出到文本框不下载)
        const config = {
            mode: 'debug',           // 关键：输出到文本框
            targetVer: 'pro_v3',     // 关键：强制生成 V3 版本
            sourceType: document.getElementById('cfg-source-type').value,
            tryNetlist: document.getElementById('cfg-netlist').checked
        };

        try {
            // 调用现有的导出逻辑
            await exportForEasyEDA_Pro(config);
            
            // 按钮反馈
            btn.textContent = "已完成";
        } catch (e) {
            console.error(e);
            btn.textContent = "失败";
        }

        setTimeout(() => btn.textContent = oldText, 1000);
    };

// ====================================================================================
// 7. UI 交互与渲染 (UI & Rendering)
// ====================================================================================

    // renderLayerTable 表格渲染 (DOM 生成)。
    function renderLayerTable() {
        const container = document.getElementById('layer-list-content');
        container.innerHTML = `
            <div class="layer-table-head">
                <div class="col-color">颜色</div>
                <div class="col-vis">启用</div>
                <div class="col-name">文件名</div>
                <div class="col-layer">图层类型</div>
            </div>
        `;

        const copperCountEl = document.getElementById('cfg-copper-layers');
        const copperCount = copperCountEl ? (parseInt(copperCountEl.value) || 2) : 2;
        const maxInnerId = 12 + copperCount; // InnerX 的最大 ID 限制

        // --- 1. 构建图层类型下拉菜单 (保持原逻辑) ---
        let selectOptionsHtml = '';
        uiGroups.forEach(group => {
            const validIds = group.ids.filter(id => {
                if (group.id === "INNER") {
                    if (copperCount <= 2) return false;
                    return id <= maxInnerId;
                }
                return true; 
            });
            if (validIds.length === 0) return; 

            selectOptionsHtml += `<optgroup label="${group.name}">`;
            validIds.forEach(id => {
                const def = layerDefs[id];
                if (def) selectOptionsHtml += `<option value="${id}">${def.name}</option>`;
            });
            selectOptionsHtml += `</optgroup>`;
        });

        // --- [新增] 2. 构建“仅铜层”下拉菜单选项 (Top, Inner..., Bottom) ---
        // 用于埋盲孔的起始/结束层选择
        let copperPairOptions = '';
        
        // Top (ID 1)
        copperPairOptions += `<option value="1">顶层线路</option>`;
        
        // Inner Layers (ID 15 ~ maxInnerId)
        // 注意：maxInnerId = 12 + copperCount. 
        // 比如 4层板: max=16 (Inner1=15, Inner2=16)
        if (copperCount > 2) {
            for (let i = 15; i < 15 + (copperCount - 2); i++) {
                // 如果 layerDefs 中有定义中文名则使用，否则用 InnerX
                const name = layerDefs[i] ? layerDefs[i].name : `内层${i-14}`;
                copperPairOptions += `<option value="${i}">${name}</option>`;
            }
        }
        
        // Bottom (ID 2)
        copperPairOptions += `<option value="2">底层线路</option>`;


        // --- 3. 渲染列表 ---
        let currentGroupId = null;

        loadedFiles.forEach(file => {
            const gid = getGroupId(file.layerId);
            const groupName = uiGroups.find(g => g.id === gid).name;

            if (gid !== currentGroupId) {
                const gDiv = document.createElement('div');
                gDiv.className = 'layer-header'; 
                gDiv.innerHTML = `
                    <input type="checkbox" id="group-cb-${gid}" onchange="toggleGroup('${gid}', this.checked)" style="margin-right:8px">
                    <span>${groupName}</span>
                `;
                container.appendChild(gDiv);
                currentGroupId = gid;
            }

            // 主行
            const row = document.createElement('div');
            row.className = 'layer-row';
            row.dataset.group = gid;
            
            const def = layerDefs[file.layerId] || layerDefs[57];
            const rowSelectHtml = selectOptionsHtml.replace(`value="${file.layerId}"`, `value="${file.layerId}" selected`);

            row.innerHTML = `
                <div class="col-color"><input type="color" value="${def.color}" onchange="updateColor(${file.layerId},this.value)"></div>
                <div class="col-vis"><input type="checkbox" class="file-cb" ${file.visible?'checked':''} onchange="toggleFile(${file.index},this.checked)"></div>
                <div class="col-name" title="${file.name}">${file.name}</div>
                <div class="col-layer"><select class="layer-select" onchange="changeLayer(${file.index},this.value)">${rowSelectHtml}</select></div>
            `;
            container.appendChild(row);

            // --- [新增] 如果是埋盲孔 (ID 502)，插入子行 ---
            if (file.layerId === 502) {
                const subRow = document.createElement('div');
                subRow.className = 'layer-sub-row';
                
                // 确定下拉框的默认值
                // 如果文件对象里没有 pairStart/End (比如手动切过来的)，默认设为 Top/Bottom
                const valStart = file.pairStart || 1; 
                const valEnd = file.pairEnd || 2;

                // 生成带有 selected 的 HTML
                const startHtml = copperPairOptions.replace(`value="${valStart}"`, `value="${valStart}" selected`);
                const endHtml = copperPairOptions.replace(`value="${valEnd}"`, `value="${valEnd}" selected`);

                subRow.innerHTML = `
                    <span>└ 从 </span>
                    <select onchange="updateViaPair(${file.index}, 'start', this.value)">${startHtml}</select>
                    <span> 到 </span>
                    <select onchange="updateViaPair(${file.index}, 'end', this.value)">${endHtml}</select>
                `;
                container.appendChild(subRow);
            }
        });

        const activeGroups = [...new Set(loadedFiles.map(f => getGroupId(f.layerId)))];
        activeGroups.forEach(gid => updateGroupCheckboxState(gid));
    }

    // drawCanvas, resizeCanvas (绘图)。
    function drawCanvas(forceNoDpr = false) {
        // --- [核心修复] ---
        // 如果是导出模式 (forceNoDpr=true)，强制 dpr=1，忽略屏幕缩放
        // 否则使用屏幕的 devicePixelRatio
        const dpr = forceNoDpr ? 1 : (window.devicePixelRatio || 1);
        
        // 1. 清空主画布 (使用逻辑像素尺寸)
        const logicalW = mainCanvas.width / dpr;
        const logicalH = mainCanvas.height / dpr;

        ctx.save();
        ctx.setTransform(1,0,0,1,0,0); // 重置矩阵以清空全屏
        ctx.clearRect(0,0, mainCanvas.width, mainCanvas.height);
        ctx.restore(); 
        
        // --- 修复：在导出模式下，由于 mainCanvas.width 重置清除了 context 状态，
        // 我们需要手动补上 scale，否则画面会极小。
        // 但在屏幕渲染模式下，scale 是由 resizeCanvas 处理的，这里不需要补。
        if (forceNoDpr) {
            ctx.save();
            ctx.scale(1, 1); // 显式重置为 1:1
        } else {
            // 屏幕渲染时，resizeCanvas 已经做过 scale(dpr, dpr) 了
            // 但为了保险，drawCanvas 内部恢复 context 状态时要小心
            ctx.save();
        }

        // 绘制原点
        ctx.save();
        ctx.translate(viewState.offsetX, viewState.offsetY);
        ctx.scale(viewState.scale, -viewState.scale); 
        ctx.beginPath(); ctx.strokeStyle = '#CCC'; ctx.lineWidth = 1/viewState.scale;
        ctx.moveTo(-200000,0); ctx.lineTo(200000,0); ctx.moveTo(0,-200000); ctx.lineTo(0,200000); ctx.stroke();
        ctx.restore();


        // 权重排序 (数值越大越靠上层显示，后绘制)
        const renderPriority = {
            // --- Level 1: 最高优先级 ---
            11: 1000, // 板框 (Outline)
            47: 900,  // 钻孔 (Drill)
            500: 900, // 金属化通孔
            501: 900, // 非金属化通孔
            502: 900, // 埋盲孔

            // --- Level 2: 顶层堆叠 (铜 < 阻焊 < 丝印 < 锡膏 < 补强 < 装配) ---
            9:  850,  // Top Assembly
            58: 840,  // Top Stiffener
            7:  830,  // Top Paste
            3:  820,  // Top Silk
            5:  810,  // Top Solder Mask
            1:  800,  // Top Copper

            // --- Level 3: 内层 (动态计算，位于 600~700 之间) ---

            // --- Level 4: 底层堆叠 (铜 < 阻焊 < 丝印 < 锡膏 < 补强 < 装配) ---
            10: 450,  // Bot Assembly
            59: 440,  // Bot Stiffener
            8:  430,  // Bot Paste
            4:  420,  // Bot Silk
            6:  410,  // Bot Solder Mask
            2:  400,  // Bot Copper

            // --- Level 5: 背景层 ---
            57: 200,  // Other
            56: 100,  // Drill Drawing
            14: 60,   // Mechanical
            13: 50    // Document
        };

        const getZ = (id) => {
            // 1. 如果在静态表中定义了，直接返回
            if (renderPriority[id] !== undefined) return renderPriority[id];
            
            // 2. 动态计算内层优先级 (Inner1 ~ Inner32 对应 ID 15 ~ 46)
            // 要求: Inner1 (ID 15) > Inner2 (ID 16) > ...
            // 算法: 基础值 600 + (最大ID 46 - 当前ID)
            // 结果: Inner1 (15) => 600 + 31 = 631
            //       Inner32 (46) => 600 + 0 = 600
            if (id >= 15 && id <= 46) {
                return 600 + (46 - id); 
            }
            
            return 0; // 未知图层沉底
        };
        
        // 排序
        const renderOrder = loadedFiles.slice().sort((a,b) => getZ(a.layerId) - getZ(b.layerId));


        // 2. 循环绘制每个文件
        renderOrder.forEach(file => {
            if (!file.visible) return;
            const def = layerDefs[file.layerId] || layerDefs[57] || { color: '#888', alpha: 1 };

            // A. 清空 Buffer
            bufCtx.save();
            bufCtx.setTransform(1,0,0,1,0,0);
            bufCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            bufCtx.restore(); // 如果 bufferCanvas 上下文没有做 dpr scale，这里其实不需要 restore，但为了安全
            
            // B. Buffer 绘图设置
            bufCtx.save();
            // 关键：Buffer 也要应用 dpr 和 视图变换
            bufCtx.scale(dpr, dpr); 
            bufCtx.translate(viewState.offsetX, viewState.offsetY);
            bufCtx.scale(viewState.scale, -viewState.scale);

            bufCtx.fillStyle = def.color;
            bufCtx.strokeStyle = def.color;
            if(file.layerId === 47) { bufCtx.fillStyle="#ffffff"; bufCtx.strokeStyle="#ffffff"; }
            
            // ... (原有的绘制 Loop 保持不变，包含 commands 遍历) ...
            const { commands, apertures } = file.data;
            let currX=0, currY=0;
            bufCtx.lineCap = 'round'; bufCtx.lineJoin = 'round'; 
            bufCtx.beginPath();

            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];

                // 极性处理
                if (cmd.polarity === 'C') {
                    bufCtx.stroke(); 
                    bufCtx.beginPath();
                    bufCtx.globalCompositeOperation = 'destination-out'; 
                } else {
                    bufCtx.stroke(); 
                    bufCtx.beginPath();
                    bufCtx.globalCompositeOperation = 'source-over'; 
                }

                if (cmd.type === 2) { // Move
                    bufCtx.stroke(); 
                    bufCtx.beginPath();
                    bufCtx.moveTo(cmd.x, cmd.y);
                    currX = cmd.x; currY = cmd.y;
                } else if (cmd.type === 1) { // Line / Arc
                    const ap = apertures[cmd.ap];
                    const width = (ap && ap.params && ap.params[0]) ? ap.params[0] : (0.05);
                    
                    if (bufCtx.lineWidth !== width) {
                        bufCtx.stroke(); bufCtx.beginPath();
                        bufCtx.lineWidth = width;
                        bufCtx.moveTo(currX, currY); 
                    }
                    
                    if (cmd.mode === 2 || cmd.mode === 3) { 
                        const cx = cmd.prevX + cmd.i; const cy = cmd.prevY + cmd.j;
                        const radius = Math.sqrt(cmd.i*cmd.i + cmd.j*cmd.j);
                        const sa = Math.atan2(cmd.prevY - cy, cmd.prevX - cx);
                        const ea = Math.atan2(cmd.y - cy, cmd.x - cx);
                        bufCtx.arc(cx, cy, radius, sa, ea, cmd.mode === 2);
                    } else {
                        bufCtx.lineTo(cmd.x, cmd.y);
                    }
                    currX = cmd.x; currY = cmd.y;
                } else if (cmd.type === 3) { // Flash (D03)
                    bufCtx.stroke(); bufCtx.beginPath();
                    const ap = apertures[cmd.ap];
                    const safeAp = ap || { type:'C', params:[0.2] }; 
                    
                    // 【修改注意】: 这里不要直接转大写，因为宏名称是区分大小写的
                    const rawType = safeAp.type; 
                    const type = rawType.toUpperCase(); 
                    const p = safeAp.params || [];

                    // 获取宏定义 (注意 file.data.macros 是第一步 parse 返回的)
                    const macros = file.data.macros || {}; 

                    bufCtx.save();
                    bufCtx.translate(cmd.x, cmd.y);
                    
                    // 【新增】优先检查宏
                    if (macros[rawType]) {
                        const macro = macros[rawType];
                        if (macro.type === 'POLYGON' && macro.points.length > 0) {
                            bufCtx.beginPath();
                            bufCtx.moveTo(macro.points[0].x, macro.points[0].y);
                            for (let k = 1; k < macro.points.length; k++) {
                                bufCtx.lineTo(macro.points[k].x, macro.points[k].y);
                            }
                            bufCtx.closePath();
                            bufCtx.fill();
                        }
                    }
                    
                    // --- 形状绘制逻辑 (包含对 EasyEDA Pro 宏形状的支持) ---
                    
                    if (type === 'RECT' || (type === 'R' && p.length >= 2)) {
                        // 标准矩形
                        if (p.length >= 3 && p[2]) bufCtx.rotate(p[2] * Math.PI / 180); // 仅在有旋转参数时旋转
                        bufCtx.fillRect(-p[0]/2, -p[1]/2, p[0], p[1]);
                    }
                    // --- EasyEDA Pro Drill Symbols (宏映射) ---
                    else if (type.includes('ICON')) {
                        const size = 0.5; // 默认图标大小
                        const hs = size/2;
                        
                        if (type.includes('RECT')) {
                            // IconRect, IconRect2
                            bufCtx.fillRect(-hs, -hs, size, size);
                        } else if (type.includes('TRIANGLE')) {
                            // IconTriangle
                            bufCtx.beginPath();
                            bufCtx.moveTo(0, hs);
                            bufCtx.lineTo(hs, -hs);
                            bufCtx.lineTo(-hs, -hs);
                            bufCtx.closePath();
                            bufCtx.fill();
                        } else if (type.includes('DIAMOND')) {
                            // IconDiamond
                            bufCtx.beginPath();
                            bufCtx.moveTo(0, hs);
                            bufCtx.lineTo(hs, 0);
                            bufCtx.lineTo(0, -hs);
                            bufCtx.lineTo(-hs, 0);
                            bufCtx.closePath();
                            bufCtx.fill();
                        } else if (type.includes('PLUS')) {
                            // IconPlus
                            bufCtx.lineWidth = size * 0.2;
                            bufCtx.moveTo(0, -hs); bufCtx.lineTo(0, hs);
                            bufCtx.moveTo(-hs, 0); bufCtx.lineTo(hs, 0);
                            bufCtx.stroke();
                        } else if (type.includes('X')) {
                            // IconX
                            bufCtx.lineWidth = size * 0.2;
                            bufCtx.moveTo(-hs, -hs); bufCtx.lineTo(hs, hs);
                            bufCtx.moveTo(hs, -hs); bufCtx.lineTo(-hs, hs);
                            bufCtx.stroke();
                        } else if (type.includes('STAR')) {
                            // IconStar4, IconStar6 (简化为 *)
                            bufCtx.lineWidth = size * 0.15;
                            bufCtx.moveTo(0, -hs); bufCtx.lineTo(0, hs);
                            bufCtx.moveTo(-hs*0.86, -hs*0.5); bufCtx.lineTo(hs*0.86, hs*0.5);
                            bufCtx.moveTo(hs*0.86, -hs*0.5); bufCtx.lineTo(-hs*0.86, hs*0.5);
                            bufCtx.stroke();
                        } else {
                            // 未知 Icon，画个圈代替
                            bufCtx.arc(0, 0, hs, 0, Math.PI*2); bufCtx.fill();
                        }
                    }
                    // --- 标准形状 ---
                    else if (type === 'ROUNDRECT' && p.length >= 5) {
                        const dia = p[0], rad = dia/2;
                        const dx = p[3]-p[1], dy = p[4]-p[2];
                        const side1 = Math.sqrt(dx*dx + dy*dy);
                        const side2 = Math.sqrt(Math.pow(-p[1]-p[3],2) + Math.pow(-p[2]-p[4],2));
                        const rot = Math.atan2(dy, dx);
                        bufCtx.rotate(rot);
                        bufCtx.beginPath();
                        if(bufCtx.roundRect) bufCtx.roundRect(-(side1+dia)/2, -(side2+dia)/2, side1+dia, side2+dia, rad);
                        else bufCtx.rect(-(side1+dia)/2, -(side2+dia)/2, side1+dia, side2+dia);
                        bufCtx.fill();
                    }
                    else if (type === 'OVAL' && p.length === 5) {
                        bufCtx.lineCap = 'round'; bufCtx.lineWidth = p[0];
                        bufCtx.beginPath(); bufCtx.moveTo(p[1], p[2]); bufCtx.lineTo(p[3], p[4]); bufCtx.stroke();
                    }
                    else if (type === 'C') { 
                        // Circle
                        const dia = p[0];
                        bufCtx.beginPath(); bufCtx.arc(0, 0, dia/2, 0, Math.PI*2); bufCtx.fill();
                        
                        // 兼容处理：如果 C 后面跟了两个参数 (例如 EasyEDA Pro 的 0.44X0.37)，
                        // 虽然这不符合标准 Gerber C 的定义，但为了避免空白，我们忽略第二个参数或将其视为孔。
                        // 标准逻辑是：param[1] 是孔径。
                        if (p.length > 1 && p[1] > 0) {
                             bufCtx.globalCompositeOperation = "destination-out";
                             bufCtx.beginPath(); bufCtx.arc(0,0,p[1]/2, 0, Math.PI*2); bufCtx.fill();
                             // 恢复
                             bufCtx.globalCompositeOperation = cmd.polarity === 'C' ? 'destination-out' : 'source-over';
                        }
                    } 
                    else if (type === 'O') { // Obround
                        const w=p[0], h=p[1], r=Math.min(w,h)/2;
                        bufCtx.beginPath();
                        if(bufCtx.roundRect) bufCtx.roundRect(-w/2, -h/2, w, h, r); else bufCtx.rect(-w/2, -h/2, w, h);
                        bufCtx.fill();
                        if (p.length > 2 && p[2] > 0) { // Hole
                             bufCtx.globalCompositeOperation = "destination-out";
                             bufCtx.beginPath(); bufCtx.arc(0,0,p[2]/2, 0, Math.PI*2); bufCtx.fill();
                             bufCtx.globalCompositeOperation = cmd.polarity === 'C' ? 'destination-out' : 'source-over';
                        }
                    }
                    
                    bufCtx.restore();
                    bufCtx.beginPath(); bufCtx.moveTo(cmd.x, cmd.y); currX = cmd.x; currY = cmd.y;

                } else if (cmd.type === 4) { // Region
                    bufCtx.stroke(); bufCtx.beginPath(); 
                    cmd.path.forEach(op => {
                        if (op.cmd === 'M') bufCtx.moveTo(op.x, op.y);
                        else if (op.cmd === 'L') bufCtx.lineTo(op.x, op.y);
                        else if (op.cmd === 'A') {
                            const cx = op.startX + op.i, cy = op.startY + op.j;
                            const r = Math.sqrt(op.i*op.i + op.j*op.j);
                            const sa = Math.atan2(op.startY - cy, op.startX - cx);
                            const ea = Math.atan2(op.y - cy, op.x - cx);
                            bufCtx.arc(cx, cy, r, sa, ea, op.mode === 2);
                        }
                    });
                    bufCtx.closePath(); bufCtx.fill('evenodd'); 
                    bufCtx.beginPath(); 
                    if (cmd.path.length > 0) {
                        const last = cmd.path[cmd.path.length-1];
                        currX = last.x; currY = last.y;
                        bufCtx.moveTo(currX, currY); 
                    }
                } else if (cmd.type === 6) { //槽孔 (Slot) 绘制逻辑
                    bufCtx.stroke(); bufCtx.beginPath();
                    
                    const ap = apertures[cmd.ap];
                    // 获取钻刀直径
                    const dia = (ap && ap.params && ap.params[0]) ? ap.params[0] : 0.1;
                    
                    // 设置绘制样式：线宽=直径，线端=圆头
                    bufCtx.lineWidth = dia;
                    bufCtx.lineCap = 'round';
                    bufCtx.lineJoin = 'round';
                    
                    // 绘制直线（因为线宽和线端样式的存在，会自动变成两头圆的槽）
                    bufCtx.moveTo(cmd.startX, cmd.startY);
                    bufCtx.lineTo(cmd.x, cmd.y);
                    
                    bufCtx.stroke();
                    
                    // 重置，防止影响后续绘图
                    bufCtx.beginPath();
                    currX = cmd.x; currY = cmd.y;
                }
            }
            bufCtx.stroke();
            bufCtx.restore();

            // C. 合成 (注意 drawImage 时因为 ctx 已经 scale 了 dpr，
            // 而 bufferCanvas 本身是 dpr 倍大的，所以绘制尺寸要除以 dpr 或者调整 drawImage 参数)
            
            ctx.save();
            ctx.globalAlpha = def.alpha;
            // 关键：因为 ctx 已经 scale(dpr, dpr)，这里绘制逻辑尺寸即可
            // bufferCanvas 是物理像素尺寸，drawImage 会自动映射
            ctx.drawImage(bufferCanvas, 0, 0, logicalW, logicalH);
            ctx.restore();
        });
        // 仅在非导出模式下绘制标尺
        if (!forceNoDpr) drawRulers();
    }

    function resizeCanvas() {
        const c = document.getElementById('canvas-container');
        const dpr = window.devicePixelRatio || 1;
        
        // 1. 设置物理像素 (用于清晰度)
        mainCanvas.width = c.clientWidth * dpr;
        mainCanvas.height = c.clientHeight * dpr;
        
        rulerH.width = c.clientWidth * dpr;
        rulerH.height = 20 * dpr; // 标尺高度固定
        rulerV.width = 20 * dpr;
        rulerV.height = c.clientHeight * dpr;
        
        bufferCanvas.width = mainCanvas.width;
        bufferCanvas.height = mainCanvas.height;

        // 2. 设置 CSS 尺寸 (用于布局)
        mainCanvas.style.width = c.clientWidth + 'px';
        mainCanvas.style.height = c.clientHeight + 'px';
        rulerH.style.width = c.clientWidth + 'px';
        rulerH.style.height = '20px';
        rulerV.style.width = '20px';
        rulerV.style.height = c.clientHeight + 'px';

        // 3. 规范化坐标系：所有绘图操作依然使用 CSS 像素逻辑，Scale 自动处理 HiDPI
        ctx.scale(dpr, dpr);
        ctxH.scale(dpr, dpr);
        ctxV.scale(dpr, dpr);
        // buffer 不需要 scale，因为它是在内部 transform 处理的，或者也统一 scale

        requestDraw(); // 触发重绘
    }


    // switchTab, setUnitUI (简单的 UI 响应)。
    // --- UI 切换逻辑 (新增) ---
    function switchTab(tabId, btnElement) {
        // 1. 切换 Tab 样式
        document.querySelectorAll('.tab-item').forEach(t => t.classList.remove('active'));
        btnElement.classList.add('active');

        // 2. 切换内容显示
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
    }

    // --- UI 控件适配逻辑 (适配新界面) ---
    function setUnitUI(val, type) {
        // 视觉切换
        const group = document.getElementById(`ui-units-group-${type}`);
        if (group) {
            group.querySelectorAll('.seg-btn').forEach(btn => {
                if(btn.dataset.val === val) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        }

        // 逻辑映射
        if (type === 'graphic') {
            document.getElementById('cfg-units').value = val;
        } 
        // --- 【新增】钻孔单位逻辑 ---
        else if (type === 'drill') {
            document.getElementById('cfg-d-units').value = val;
        }
    }



    // --- 排序与索引重置辅助函数 ---
    function sortLoadedFiles() {
        // 1. 创建优先级映射表
        const idPriority = {};
        let pCounter = 0;
        uiGroups.forEach(g => g.ids.forEach(id => idPriority[id] = pCounter++));
        
        // 2. 根据图层ID的优先级进行排序
        loadedFiles.sort((a,b) => {
            const pa = idPriority[a.layerId] !== undefined ? idPriority[a.layerId] : 9999;
            const pb = idPriority[b.layerId] !== undefined ? idPriority[b.layerId] : 9999;
            return pa - pb;
        });
        
        // 3. 关键修复：重新分配索引 (index)
        loadedFiles.forEach((f, i) => f.index = i);
    }

    // --- [新增] 更新板子属性统计 ---
    function updateBoardStats() {
        // 1. 层数 (直接读取设置)
        const layerEl = document.getElementById('cfg-copper-layers');
        const layerCount = layerEl ? layerEl.value : 2;
        document.getElementById('prop-layers').textContent = layerCount;

        // 2. 尺寸 (基于板框层 ID 11 的包围盒)
        const outlineFile = loadedFiles.find(f => f.layerId === 11);
        const dimEl = document.getElementById('prop-dim');
        
        if (outlineFile) {
            const b = outlineFile.data.bounds;
            if (b.minX !== Infinity && b.maxX !== -Infinity) {
                const w = (b.maxX - b.minX).toFixed(3);
                const h = (b.maxY - b.minY).toFixed(3);
                dimEl.textContent = `${w} x ${h} mm`;
            } else {
                dimEl.textContent = "无法计算";
            }
        } else {
            dimEl.textContent = "未找到板框";
        }

        // 3. 钻孔统计
        let thCount = 0; // 通孔 (ID 47, 500, 501)
        let bbCount = 0; // 埋盲孔 (ID 502)

        loadedFiles.forEach(f => {
            // 统计 Flash 指令 (Type 3) 作为孔的数量
            // 注意：某些通过 G85 槽孔定义的钻孔可能在 parse 阶段被转换，这里主要统计 Flash
            const flashCount = f.data.commands.filter(c => c.type === 3).length;

            if (f.layerId === 47 || f.layerId === 500 || f.layerId === 501) {
                thCount += flashCount;
            } else if (f.layerId === 502) {
                bbCount += flashCount;
            }
        });

        document.getElementById('prop-th').textContent = thCount;
        
        const bbRow = document.getElementById('row-prop-bb');
        const bbEl = document.getElementById('prop-bb');
        
        if (bbCount > 0) {
            bbEl.textContent = bbCount;
            bbRow.style.display = 'flex';
        } else {
            bbRow.style.display = 'none';
        }
    }

    // 自动适配视图
    function autoFitView() {
        if (loadedFiles.length === 0) return;
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        loadedFiles.forEach(f => {
            const b = f.data.bounds;
            if(b.minX !== Infinity) {
                minX = Math.min(minX, b.minX); maxX = Math.max(maxX, b.maxX);
                minY = Math.min(minY, b.minY); maxY = Math.max(maxY, b.maxY);
            }
        });
        if(minX === Infinity) return;
        const w = maxX - minX; const h = maxY - minY;
        const cx = (minX + maxX) / 2; const cy = (minY + maxY) / 2;
        const cw = document.getElementById('canvas-container').clientWidth;
        const ch = document.getElementById('canvas-container').clientHeight;
        const scaleX = cw / (w * 1.2 || 100); const scaleY = ch / (h * 1.2 || 100);
        viewState.scale = Math.min(scaleX, scaleY);
        if(!isFinite(viewState.scale)) viewState.scale = 10;
        viewState.offsetX = cw / 2 - cx * viewState.scale; 
        viewState.offsetY = ch / 2 + cy * viewState.scale;
    }

    // 辅助：获取图层所属的组ID
    function getGroupId(layerId) {
        let group = uiGroups.find(g => g.ids.includes(layerId));
        if (!group) group = uiGroups[4]; // 默认为自定义/其他
        return group.id;
    }

    // 辅助：更新指定组的复选框状态 (核心逻辑)
    function updateGroupCheckboxState(gid) {
        const groupCb = document.getElementById(`group-cb-${gid}`);
        if (!groupCb) return;

        // 找到该组下的所有文件
        const groupFiles = loadedFiles.filter(f => getGroupId(f.layerId) === gid);
        
        if (groupFiles.length === 0) {
            groupCb.checked = false;
            groupCb.indeterminate = false;
            return;
        }

        const total = groupFiles.length;
        const visibleCount = groupFiles.filter(f => f.visible).length;

        if (visibleCount === 0) {
            // 1. 全不选
            groupCb.checked = false;
            groupCb.indeterminate = false;
        } else if (visibleCount === total) {
            // 2. 全选
            groupCb.checked = true;
            groupCb.indeterminate = false;
        } else {
            // 3. 半选 (显示横线)
            groupCb.checked = false; // 这里设为false或true都可以，关键是下一行
            groupCb.indeterminate = true;
        }
    }

    // 更新颜色
    window.updateColor = (id, val) => { if(layerDefs[id]) layerDefs[id].color = val; drawCanvas(); };

    // --- [新增] 更新埋盲孔层对信息 ---
    window.updateViaPair = (idx, type, val) => {
        const file = loadedFiles[idx];
        if (!file) return;
        
        const layerVal = parseInt(val);
        if (type === 'start') {
            file.pairStart = layerVal;
        } else {
            file.pairEnd = layerVal;
        }
        console.log(`File [${file.name}] pair updated: ${file.pairStart} -> ${file.pairEnd}`);
    };

    // 切换组可见性
    window.toggleGroup = (gid, isChecked) => { 
        // 1. 更新数据状态
        let hasChanged = false;
        loadedFiles.forEach(f => {
            if (getGroupId(f.layerId) === gid) {
                if (f.visible !== isChecked) {
                    f.visible = isChecked;
                    hasChanged = true;
                }
            }
        });

        // 2. 更新 DOM：同步下方所有子项的复选框
        if (hasChanged) {
            // 找到所有属于该组的行内的复选框
            const rows = document.querySelectorAll(`.layer-row[data-group="${gid}"] .file-cb`);
            rows.forEach(cb => cb.checked = isChecked);
            
            // 3. 更新自身状态 (清除半选样式)
            const groupCb = document.getElementById(`group-cb-${gid}`);
            if (groupCb) groupCb.indeterminate = false;

            drawCanvas();
        }
    };

    // 切换单文件可见性
    window.toggleFile = (idx, isChecked) => { 
        // 1. 更新文件可见性
        const file = loadedFiles[idx];
        file.visible = isChecked; 
        
        // 2. 反向更新组复选框状态 (核心修改)
        const gid = getGroupId(file.layerId);
        updateGroupCheckboxState(gid);

        // 3. 重绘
        drawCanvas(); 
    };
    
    // 2. 修改图层类型
    window.changeLayer = (idx, val) => { 
        const newId = parseInt(val);
        const file = loadedFiles[idx];
        
        // 如果旧的不是 502，新的变成了 502，或者反之，都需要重新渲染子行
        const needsRerender = (file.layerId === 502) !== (newId === 502);

        file.layerId = newId; 

        if (newId === 58 || newId === 59) setBoardType('FPC');

        sortLoadedFiles();
        
        // 关键修改：如果涉及 502 变化，必须 renderLayerTable 才能显示/隐藏下拉框
        // 简单的做法是任何类型改变都重绘表格，不仅更安全，代码也更少
        renderLayerTable(); 
        drawCanvas(); 
    };

    // 请求绘制帧
    function requestDraw() {
        if (!isRenderPending) {
            isRenderPending = true;
            requestAnimationFrame(() => {
                drawCanvas();
                isRenderPending = false;
            });
        }
    }

    // --- 标尺绘制 (适配 HiDPI + 自适应步进算法 1-2-5序列) ---
    function drawRulers() {
        const dpr = window.devicePixelRatio || 1;
        
        // 1. 使用逻辑尺寸清空画布 (适配 Retina/HiDPI)
        const logicalW = rulerH.width / dpr;
        const logicalH = rulerH.height / dpr;
        const logicalVH = rulerV.height / dpr;
        const logicalVW = rulerV.width / dpr;

        // ctxH/V 已经在 resizeCanvas 中被 scale(dpr, dpr)
        ctxH.clearRect(0, 0, logicalW, logicalH);
        ctxV.clearRect(0, 0, logicalVW, logicalVH);

        // 2. 自适应步进计算核心逻辑
        const isMM = viewState.unit === 'mm';
        const mmToMil = 39.3700787;
        
        // [核心配置] 屏幕上理想的刻度间距 (像素)
        // 算法会尝试让刻度间距接近这个值
        const idealSpacingPx = 80; 
        
        // 计算当前缩放比例下，理想间距对应的"物理世界"距离 (单位: mm)
        // viewState.scale 是 px/mm
        const rawStepWorldMM = idealSpacingPx / viewState.scale;
        
        // 根据当前显示单位，转换到目标单位域进行"吸附"
        // 如果是 mil 模式，我们希望吸附到 100mil, 50mil 这种整数，而不是 2.54mm 的倍数
        let stepRawDisplay; 
        if (isMM) {
            stepRawDisplay = rawStepWorldMM;
        } else {
            stepRawDisplay = rawStepWorldMM * mmToMil;
        }

        // --- 1-2-5 序列吸附算法 ---
        // 计算数量级 (例如 0.35 -> magnitude=0.1, 35 -> magnitude=10)
        const magnitude = Math.pow(10, Math.floor(Math.log10(stepRawDisplay)));
        // 计算残差 (例如 0.35/0.1 = 3.5)
        const residual = stepRawDisplay / magnitude;
        
        // 查表吸附：选择最接近的标准化步进 (1, 2, 5)
        let standardStep;
        if (residual < 1.5) standardStep = 1;       // 1.0, 10, 0.1
        else if (residual < 3.5) standardStep = 2;  // 2.0, 20, 0.2
        else standardStep = 5;                      // 5.0, 50, 0.5
        
        // 最终计算出的"漂亮"的显示步进 (单位跟随 viewState.unit)
        const niceDisplayStep = standardStep * magnitude; 
        
        // 将步进转换回世界坐标系 (mm)，用于后续绘图循环
        const worldStep = isMM ? niceDisplayStep : (niceDisplayStep / mmToMil);

        // --- 自动精度计算 ---
        // 避免出现 0.300000004 这种情况
        // 如果步进是 0.1，精度设为 1；步进是 0.5，精度设为 1；步进是 10，精度设为 0
        let precision = 0;
        if (niceDisplayStep < 1) {
             precision = Math.max(0, Math.ceil(-Math.log10(niceDisplayStep)));
        }

        // 3. 样式设置
        ctxH.fillStyle = '#aaa'; ctxH.font = '10px Arial'; ctxH.textAlign = 'left'; ctxH.strokeStyle = '#555';
        ctxV.fillStyle = '#aaa'; ctxV.font = '10px Arial'; ctxV.textAlign = 'right'; ctxV.textBaseline = 'middle'; ctxV.strokeStyle = '#555';

        // 4. 绘制 X 轴标尺 (Horizontal)
        // 计算可见区域的世界坐标范围
        const startWorldX = -viewState.offsetX / viewState.scale;
        const endWorldX = (logicalW - viewState.offsetX) / viewState.scale;
        
        // 对齐起始点 (Snap to Grid)
        // 关键：必须从 worldStep 的整数倍开始画，否则刻度会浮动
        // 增加 buffer 防止边缘刻度没画出来
        const startTickX = Math.floor(startWorldX / worldStep) * worldStep;
        
        ctxH.beginPath();
        for (let x = startTickX; x < endWorldX + worldStep; x += worldStep) {
            const screenX = x * viewState.scale + viewState.offsetX;
            
            // 剔除屏幕外的绘制指令 (性能优化)
            if (screenX < -50 || screenX > logicalW + 50) continue;

            // 绘制主刻度线
            ctxH.moveTo(screenX, 0); ctxH.lineTo(screenX, 20);
            
            // 计算标签数值
            let labelVal = isMM ? x : (x * mmToMil);
            
            // [防抖动] 处理 -0.000 问题
            if (Math.abs(labelVal) < 1e-10) labelVal = 0;
            
            // 格式化文字 (应用自动精度)
            const labelStr = labelVal.toFixed(precision);
            ctxH.fillText(labelStr, screenX + 4, 12);

            // 绘制次级刻度 (简单二分)
            const subX = screenX + (worldStep / 2) * viewState.scale;
            if (subX < logicalW) {
                 ctxH.moveTo(subX, 15); ctxH.lineTo(subX, 20);
            }
        }
        ctxH.stroke();

        // 5. 绘制 Y 轴标尺 (Vertical)
        // 注意：Canvas Y轴向下，但 PCB 坐标通常向上，viewState transform 中 Y 是翻转的 (-scale)
        // 视口顶部的世界坐标 (World Y at Screen Top)
        const topWorldY = viewState.offsetY / viewState.scale;
        // 视口底部的世界坐标 (World Y at Screen Bottom)
        const bottomWorldY = (viewState.offsetY - logicalVH) / viewState.scale;
        
        // 对齐起始点
        const startTickY = Math.floor(topWorldY / worldStep) * worldStep;
        
        ctxV.beginPath();
        // 因为坐标系翻转，WorldY 从上到下是减小的，所以用减法遍历
        for (let y = startTickY; y > bottomWorldY - worldStep; y -= worldStep) {
            const screenY = viewState.offsetY - y * viewState.scale;
            
            if (screenY < -50 || screenY > logicalVH + 50) continue;

            // 绘制主刻度线
            ctxV.moveTo(0, screenY); ctxV.lineTo(20, screenY);
            
            let labelVal = isMM ? y : (y * mmToMil);
            if (Math.abs(labelVal) < 1e-10) labelVal = 0;
            const labelStr = labelVal.toFixed(precision);
            
            // 旋转文字使其垂直阅读更自然
            ctxV.save(); 
            ctxV.translate(10, screenY - 2); 
            ctxV.rotate(-Math.PI/2);
            ctxV.fillText(labelStr, -2, 0); 
            ctxV.restore();

            // 绘制次级刻度
            // 注意：屏幕 Y 向下增加，World Y 减小，所以次级刻度在当前刻度的"下方" (screenY + halfStep)
            const subY = screenY + (worldStep / 2) * viewState.scale;
            if (subY < logicalVH) {
                ctxV.moveTo(15, subY); ctxV.lineTo(20, subY);
            }
        }
        ctxV.stroke();
        
        // 6. 填充左上角死角背景
        ctxH.fillStyle = '#252526'; ctxH.fillRect(0,0,20,20);
    }

    // --- 7. 鼠标交互 (优化版：带缩放限制) ---
    mainCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        // 1. 获取鼠标当前在画布上的位置
        const rect = mainCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // 2. 计算鼠标指向的世界坐标 (缩放前的实际物理坐标)
        const wx = (mx - viewState.offsetX) / viewState.scale;
        const wy = (viewState.offsetY - my) / viewState.scale;

        // 3. 预计算新的缩放值
        const zoomFactor = e.deltaY < 0 ? 1.5 : 0.6666;
        let newScale = viewState.scale * zoomFactor;

        // --- [新增] 缩放限制逻辑 ---
        // 获取画布当前最小边长 (用于计算适配比例)
        const minScreenDim = Math.min(mainCanvas.clientWidth, mainCanvas.clientHeight) || 500;

        // 限制 A: 缩小限制 (最大可视范围 10000mm)
        const minScale = minScreenDim / 10000;

        // 限制 B: 放大限制 (最小可视范围 0.02mm)
        const maxScale = minScreenDim / 0.02;

        // 执行截断
        if (newScale < minScale) newScale = minScale;
        if (newScale > maxScale) newScale = maxScale;
        // ---------------------------

        // 4. 应用新的缩放值
        viewState.scale = newScale;

        // 5. 反向计算 Offset，确保鼠标指向的世界坐标位置不变 (实现以鼠标为中心缩放)
        viewState.offsetX = mx - wx * viewState.scale;
        viewState.offsetY = my + wy * viewState.scale; 

        requestDraw(); // 使用异步绘制
    }, { passive: false }); // 显式声明非被动，确保 preventDefault 生效

    // 鼠标按下事件
    mainCanvas.addEventListener('mousedown', (e) => {
        if (e.button===2 || e.button===1) {
            viewState.isDragging = true;
            viewState.lastX = e.clientX; viewState.lastY = e.clientY;
            mainCanvas.style.cursor = 'grabbing';
        }
    });
    
    // 鼠标移动事件
    window.addEventListener('mousemove', (e) => {
        if (viewState.isDragging) {
            viewState.offsetX += e.clientX - viewState.lastX;
            viewState.offsetY += e.clientY - viewState.lastY;
            viewState.lastX = e.clientX; viewState.lastY = e.clientY;
            requestDraw(); // 使用异步绘制
        }
    });
    
    // 鼠标松开事件
    window.addEventListener('mouseup', () => { viewState.isDragging=false; mainCanvas.style.cursor='default'; });
    
    // 右键菜单屏蔽
    mainCanvas.addEventListener('contextmenu', e=>e.preventDefault());
    
    // 单位切换按钮事件
    document.getElementById('unit-btn').addEventListener('click', function() {
        viewState.unit = viewState.unit==='mm'?'mil':'mm';
        this.textContent = viewState.unit;
        drawCanvas();
    });

    // --- 修复后的步进器与UI同步逻辑 ---

    // 2. 步进器调整 (支持所有整数位/小数位调整)
    window.stepVal = (targetId, delta) => {
        const input = document.getElementById(targetId);
        if (!input) return;

        let val = parseInt(input.value) + delta;
        // 限制范围 1 ~ 8
        if (val < 1) val = 1;
        if (val > 8) val = 8;
        
        input.value = val;
        
        // 立即更新对应的 UI 显示文本
        // 规则：ID 为 'cfg-dec' 对应 'ui-val-dec'
        // 其他规则：'cfg-xxx' 对应 'ui-val-xxx'
        let uiId = "";
        if (targetId === 'cfg-dec') {
            uiId = 'ui-val-dec';
        } else {
            uiId = targetId.replace('cfg', 'ui-val');
        }
        
        const uiEl = document.getElementById(uiId);
        if (uiEl) uiEl.textContent = val;
    };

    // 3. 核心：从隐藏 Input 同步状态到 UI 显示
    // (在自动检测、重置、手动点击后调用)
    window.syncUiFromState = function() {
        // 同步单位按钮状态
        const currentUnit = document.getElementById('cfg-units').value;
        setUnitUI(currentUnit, 'graphic'); // 确保图形单位UI同步
        
        // --- 修复：同步所有数值显示 ---
        
        // 1. 图形参数
        const gInt = document.getElementById('cfg-g-int').value;
        const gDec = document.getElementById('cfg-dec').value;
        if(document.getElementById('ui-val-g-int')) document.getElementById('ui-val-g-int').textContent = gInt;
        if(document.getElementById('ui-val-dec')) document.getElementById('ui-val-dec').textContent = gDec;

        // 2. 钻孔参数
        const dInt = document.getElementById('cfg-d-int').value;
        const dDec = document.getElementById('cfg-d-dec').value;
        if(document.getElementById('ui-val-d-int')) document.getElementById('ui-val-d-int').textContent = dInt;
        if(document.getElementById('ui-val-d-dec')) document.getElementById('ui-val-d-dec').textContent = dDec;
    };
    // --- 新增：DPI 联动逻辑 ---

    // 1. 点击预设按钮调用
    window.updateDpiUI = (val) => {
        val = parseInt(val);
        // 更新隐藏的核心配置 Input
        document.getElementById('cfg-dpi').value = val;
        
        // 更新输入框显示
        document.getElementById('ui-dpi-input').value = val;
        
        // 更新按钮高亮状态
        highlightDpiBtn(val);
    };

    // 2. 手动输入时调用
    window.handleCustomDpiInput = (val) => {
        if (!val) return;
        const numVal = parseInt(val);
        
        // 更新隐藏的核心配置 Input
        document.getElementById('cfg-dpi').value = numVal;
        
        // 尝试匹配按钮高亮 (如果输入的是 1200，则高亮 1200 按钮，否则取消所有高亮)
        highlightDpiBtn(numVal);
    };

    // 辅助：高亮匹配的按钮
    function highlightDpiBtn(val) {
        // 修改点：这里的 ID 从 #ui-dpi-presets 改为 #ui-dpi-group，以匹配 HTML
        document.querySelectorAll('#ui-dpi-group .dpi-btn').forEach(btn => {
            if (parseInt(btn.dataset.val) === val) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }

    // 为了兼容原有的 setDpi 调用 (如果还有遗漏的旧代码调用它)
    window.setDpi = window.updateDpiUI;
    
    // 2. 处理铜层数变更
    window.handleLayerCountChange = (val) => {
        console.log("当前铜层数设置为:", val);
        
        // 关键：层数改变后，重新渲染表格，触发 renderLayerTable 中的过滤逻辑
        renderLayerTable();

        // [新增] 同步更新属性面板显示的层数
        if(document.getElementById('prop-layers')) {
            document.getElementById('prop-layers').textContent = val;
        }
    };

    // 1. 设置板子类型并更新 UI (FPC/PCB)
    window.setBoardType = (type) => {
        // 更新隐藏输入框的值
        const input = document.getElementById('cfg-board-type');
        if (input) input.value = type;

        // 更新按钮的高亮激活状态
        const group = document.getElementById('ui-board-type');
        if (group) {
            group.querySelectorAll('.seg-btn').forEach(btn => {
                if (btn.dataset.val === type) {
                    btn.classList.add('active'); // 激活目标按钮
                } else {
                    btn.classList.remove('active'); // 取消其他按钮
                }
            });
        }
        console.log(`Board Type switched to: ${type}`);
    };

// ====================================================================================
// 8. 初始化入口 (Init)
// ====================================================================================

    // DOMContentLoaded 事件监听。
    // initLayerSelect。
    // 1. 初始化铜层数选择器 (1, 2, 4, 6 ... 32)
    function initLayerSelect() {
        const select = document.getElementById('cfg-copper-layers');
        if (!select) return;

        // 记录当前值（如果有），防止重置时丢失用户的选择
        const oldVal = select.value;

        select.innerHTML = ''; // 清空

        const layers = [1, 2];
        for (let i = 4; i <= 32; i += 2) {
            layers.push(i);
        }

        layers.forEach(num => {
            const option = document.createElement('option');
            option.value = num;
            option.textContent = num + ' 层板';
            select.appendChild(option);
        });

        // 恢复值或设默认值
        if (oldVal && layers.includes(parseInt(oldVal))) {
            select.value = oldVal;
        } else {
            select.value = 2; 
        }
    }
    
    // 全局拖拽事件处理
    const dropZone = document.getElementById('global-drop-zone');
    let dragCounter = 0; // 计数器，防止进入子元素时闪烁

    // 重置配置 (Reset)
    window.resetConfig = () => {
        // --- 1. 无文件时的硬重置 ---
        if (!rawFilesCache || rawFilesCache.length === 0) {
            document.getElementById('cfg-units').value = 'mm';
            document.getElementById('cfg-g-int').value = 2;
            document.getElementById('cfg-dec').value = 5;
            document.getElementById('cfg-d-int').value = 2;
            document.getElementById('cfg-d-dec').value = 4;
            document.getElementById('cfg-source-type').value = 'other';
            
            // 显式重置两个单位面板的 UI
            if (window.setUnitUI) {
                setUnitUI('mm', 'graphic');
                setUnitUI('mm', 'drill'); // <--- 新增：重置钻孔单位 UI
            }
            
            if (window.syncUiFromState) window.syncUiFromState();
            return;
        }

        // --- 2. 有文件时的智能检测重置 ---
        let detectedG = { int: null, dec: null }; // 图形精度
        let detectedD = { int: null, dec: null }; // 钻孔精度
        let detectedSource = 'easyedapro';
        let detectedGraphicUnit = 'mm'; 
        let detectedDrillUnit = 'mm'; // <--- 新增：钻孔单位检测变量

        // 遍历缓存文件进行检测
        for (const file of rawFilesCache) {
            const content = file.content;
            
            // A. 检测来源
            // if (content.includes("EasyEDA Pro")) detectedSource = 'easyedapro';
            // else if (content.includes("Altium") && detectedSource !== 'easyedapro') detectedSource = 'ad';


            // B. 检测图形单位 (G70/MOIN)
            if (content.match(/(?:^|\n)(?:%MOIN|G70)/) || content.includes("Units: Imperial")) {
                detectedGraphicUnit = 'in';
            }

            // C. 检测钻孔单位 (METRIC/INCH)
            // 只有当文件看起来像钻孔文件时才检测
            if (content.indexOf('M48') !== -1 || file.name.match(/\.(drl|txt|xln)$/i)) {
                if (content.match(/INCH|M72/i)) {
                    detectedDrillUnit = 'in';
                } else if (content.match(/METRIC|M71/i)) {
                    detectedDrillUnit = 'mm';
                }
            }

            // D. 检测 Gerber 图形精度
            const g04Match = content.match(/(\d+)\s*integers\s+(?:and\s+)?(\d+)\s+decimals/i);
            if (g04Match && !detectedG.int) {
                detectedG.int = parseInt(g04Match[1]);
                detectedG.dec = parseInt(g04Match[2]);
            }
            if (!detectedG.int) {
                const fsMatch = content.match(/%FS[LTAI]*[XY](\d)(\d)/i);
                if (fsMatch) {
                    detectedG.int = parseInt(fsMatch[1]);
                    detectedG.dec = parseInt(fsMatch[2]);
                }
            }

            // E. 检测 Drill 钻孔精度
            if (!detectedD.int && (content.indexOf('M48') !== -1 || file.name.match(/\.(drl|txt|xln)$/i))) {
                const drillMatch = content.match(/(?:METRIC|INCH).*?,([0-9\.]+)/i);
                if (drillMatch) {
                    const fmtStr = drillMatch[1]; 
                    if (fmtStr.includes('.')) {
                        const parts = fmtStr.split('.');
                        detectedD.int = parts[0].length;
                        detectedD.dec = parts[1].length;
                    }
                }
            }
        }

        // --- 3. 将检测结果回填 ---

        // 设置图形单位
        document.getElementById('cfg-units').value = detectedGraphicUnit;
        // 【新增】设置钻孔单位到隐藏 Input
        document.getElementById('cfg-d-units').value = detectedDrillUnit; 
        
        // 设置 UI 显式状态
        if (window.setUnitUI) {
            setUnitUI(detectedGraphicUnit, 'graphic');
            setUnitUI(detectedDrillUnit, 'drill'); 
        }

        // 设置来源
        const sourceSelect = document.getElementById('cfg-source-type');
        if (sourceSelect) sourceSelect.value = detectedSource;

        // 设置精度参数 (若未检测到，使用默认值)
        document.getElementById('cfg-g-int').value = detectedG.int || 2;
        document.getElementById('cfg-dec').value = detectedG.dec || 5;

        document.getElementById('cfg-d-int').value = detectedD.int || 2;
        document.getElementById('cfg-d-dec').value = detectedD.dec || 4;

        // 4. 刷新数字显示
        if (window.syncUiFromState) window.syncUiFromState();
        
        // 5. 立即应用
        reparseFiles();
        appLog(`渲染完成`);
    };

    // 重解析文件 (Reparse)
    window.reparseFiles = () => {
        if (rawFilesCache.length === 0) return;
        
        // 获取所有配置值
        const cfgUnits = document.getElementById('cfg-units').value;
        const cfgDUnits = document.getElementById('cfg-d-units').value;
        
        const cfgGInt = parseInt(document.getElementById('cfg-g-int').value);
        const cfgGDec = parseInt(document.getElementById('cfg-dec').value);
        const cfgDInt = parseInt(document.getElementById('cfg-d-int').value);
        const cfgDDec = parseInt(document.getElementById('cfg-d-dec').value);
        
        // 构建配置对象
        const configOverride = { 
            units: cfgUnits,        // 图形单位
            drillUnits: cfgDUnits,  // 【新增】钻孔单位
            gInt: cfgGInt,
            gDec: cfgGDec,
            dInt: cfgDInt,
            dDec: cfgDDec
        };
        
        processRawFiles(configOverride);
        appLog(`渲染完成`);
    };

    // --- 初始化入口 ---
    document.addEventListener('DOMContentLoaded', () => {
        initLayerSelect();
        
        // 检测是否在嘉立创 EDA 环境中
        const isEdaEnv = typeof eda !== 'undefined';
        
        // 获取相关 DOM 元素
        const titleExport = document.getElementById('ui-export-canvas-title'); // 导出标题
        const btnExportWrapper = document.getElementById('ui-export-canvas-btn-wrapper'); // 导出按钮组
        
        const titleImportEda = document.getElementById('eda-export-title'); // [获取当前板子] 标题
        const divImportEda = document.getElementById('in-eda-gerber');     // [导入当前...] 按钮区域

        if (!isEdaEnv) {
            // --- 情况 A: 普通浏览器环境 ---
            // 1. 隐藏 [导出至 PCB 画布] (这是原来就有的逻辑)
            if (titleExport) titleExport.textContent = ''; // 或者 style.display = 'none'
            if (btnExportWrapper) btnExportWrapper.style.display = 'none';

            // 2. [新增] 隐藏 [获取当前板子] 区域
            if (titleImportEda) titleImportEda.style.display = 'none';
            if (divImportEda) divImportEda.style.display = 'none';

        } else {
            // --- 情况 B: EDA 环境 ---
            // 1. 显示 [导出至 PCB 画布]
            if (titleExport) titleExport.style.display = 'flex';
            if (btnExportWrapper) btnExportWrapper.style.display = 'block';
            
            // 2. [新增] 显示 [获取当前板子] 区域
            if (titleImportEda) titleImportEda.style.display = 'flex';
            if (divImportEda) divImportEda.style.display = 'block';
        }
        
        // --- [修改] 调试面板初始化与模式控制 ---
        const panel = document.getElementById('debug-panel');
        const title = document.getElementById('debug-panel-title');
        const genBtn = document.getElementById('btn-debug-gen');
        const textArea = document.getElementById('debug-source-area');

        // [修改] 使用 flex 布局以支持高度自适应
        if (panel) {
            panel.style.display = 'flex'; 
        }

        // document.querySelector('#generatenet').closest('div').style.display = 'none';
        document.getElementById('generatenet').style.display = 'none';

        if (typeof DEBUG !== 'undefined' && DEBUG) {
            // === DEBUG 模式 ===
            if (title) title.textContent = "图形源码 (DEBUG)";
            if (genBtn) genBtn.style.display = 'block'; 
        } else {
            // === 普通模式 (日志模式) ===
            if (title) title.textContent = "运行日志";
            if (genBtn) genBtn.style.display = 'none';  
            
            appLog(`系统就绪，等待导入...`);
        }
    });


    // 立即运行以防脚本在 DOM 之后加载
    if(document.getElementById('cfg-copper-layers')) initLayerSelect();

    window.addEventListener('dragenter', (e) => {
        e.preventDefault();
        dragCounter++;
        dropZone.classList.add('active');
    });

    window.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dragCounter--;
        if (dragCounter === 0) {
            dropZone.classList.remove('active');
        }
    });

    window.addEventListener('dragover', (e) => {
        e.preventDefault(); // 必须阻止默认行为才能触发 drop
    });

    window.addEventListener('drop', (e) => {
        e.preventDefault();
        dragCounter = 0;
        dropZone.classList.remove('active');
        
        const files = e.dataTransfer.files;
        if (files && files.length > 0) {
            handleFiles(files);
        }
    });
    
    // 遮罩层本身也需要处理 drop，防止事件没冒泡
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation(); // 停止冒泡，由这里处理
        dragCounter = 0;
        dropZone.classList.remove('active');
        
        const files = e.dataTransfer.files;
        if (files && files.length > 0) {
            handleFiles(files);
        }
    });

    window.addEventListener('resize', resizeCanvas);

    // 启动时立即执行：调整画布大小。
    resizeCanvas();

    // --- 新增：启动时将坐标原点置于画面中心 ---
    const container = document.getElementById('canvas-container');
    if (container.clientWidth > 0 && container.clientHeight > 0) {
        viewState.offsetX = container.clientWidth / 2;
        viewState.offsetY = container.clientHeight / 2;
    }

    // 启动时立即执行：绘制初始画面。
    drawCanvas();
</script>
</body>
</html>
